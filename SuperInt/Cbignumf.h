/* --------------------------------------------------------------
    Целые числа с неограниченной разрядной сеткой (версия 2.0).
    Макропараметры для базовых функций.

    http://www.imach.uran.ru/cbignum

    Copyright 1999-2010, Р.Н.Шакиров, ИМаш УрО PAH.
    All Rights Reserved.

    Код предоставляется на условиях лицензии "public domain",
    т.е. допускается свободное применение, модификация и
    распространение кода при условии сохранения копирайта
    и добавления сведений о всех внесенных изменениях.

    ДАННОЕ ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ "КАК ЕСТЬ"
    БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ, ЯВНЫХ ИЛИ ПОДРАЗУМЕВАЕМЫХ. ВЫ
    ИСПОЛЬЗУЕТЕ ЕГО НА СВОЙ СОБСТВЕННЫЙ СТРАХ И РИСК. АВТОР
    НЕ БУДЕТ НЕСТИ ОТВЕТСТВЕННОСТЬ ЗА УТРАТУ ДАННЫХ, УЩЕРБ,
    УБЫТКИ ИЛИ ЛЮБЫЕ ДРУГИЕ ВИДЫ ПОТЕРЬ ПРИ ЛЮБЫХ СПОСОБАХ
    ИСПОЛЬЗОВАНИЯ ДАННОГО ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ.
-------------------------------------------------------------- */
#ifndef _CBIGNUMF_H
#define _CBIGNUMF_H
#include "Cbnl.h"

//================================================
//      Применение ассемблерного пакета.
//================================================
//      _CBIGNUM_ASM            использовать код Cbignumf.cpp

#ifndef _CBIGNUMF_INL
#if 1
#define _CBIGNUM_ASM
#endif
#endif//_CBIGNUMF_INL

//================================================
//      Включение ассемблерной оптимизации.
//================================================
//      _CBIGNUM_HARDWARE_CBR   операции с переносом.
//      _CBIGNUM_HARDWARE_MUL   умножение.
//      _CBIGNUM_HARDWARE_DIV   деление.

#ifdef  _CBIGNUM_ASM

#ifdef  _CBNL_CBR
#if 1
#define _CBIGNUM_HARDWARE_CBR
#endif
#endif//_CBNL_CBR

#ifdef  _CBNL_MUL
#if 1
#define _CBIGNUM_HARDWARE_MUL
#endif
#endif//_CBNL_MUL

#endif//_CBIGNUM_ASM

#if 0
#define _CBIGNUM_HARDWARE_DIV
#endif

//================================================
//      Включение автоматической оптимизации.
//================================================
//      _CBIGNUM_KARATSUBA_MUL  использовать метод Карацубы, если
//                              оба числа имеют размер _CBNL_KARATSUBA_MIN
//                              и более слов.
//
//      _CBIGNUM_BLOCK_MUL      использовать блочное умножение, если
//                              оба числа имеют размер _CBNL_TAB_HIGH
//                              и более слов (блочный метод оптимален
//                              для кэша L1, теперь он заменяется
//                              более эффективным методом Карацубы,
//                              кроме случая, когда одно из чисел
//                              короче _CBNL_KARATSUBA_MIN слов).
//
//      _CBIGNUM_TERNARY_MUL    использовать ускоренный на 30% троичный
//                              метод умножения с таблицей сдвигов вместо
//                              более простого двоичного метода (теперь
//                              оба метода заменяются более эффективным
//                              аппаратным умножением, если оно доступно).
//
//      _CBIGNUM_SHIFTTAB_MUL   строить таблицы сдвигов для ускорения
//                              умножения, если оба числа имеют размер
//                              _CBNL_TAB_MIN и более слов (теперь
//                              заменяется более эффективным аппаратным
//                              умножением, если оно доступно).
//
//      _CBIGNUM_SHIFTTAB_DIV   строить таблицу сдвигов для ускорения
//                              деления и модуля, если делимое имеет
//                              на _CBNL_TAB_MIN или более слов больше,
//                              чем делитель, но не более _CBNL_TAB_MAX
//                              слов.
//
//      _CBIGNUM_REDUCE_JUMPS   Использовать дополнительные операции
//                              для сокращения числа условных переходов.
//                              Неэффективно на популярных микропроцессорах.

#if 1
#define _CBIGNUM_KARATSUBA_MUL
#endif

#if 1
#define _CBIGNUM_BLOCK_MUL
#endif

#if 1
#define _CBIGNUM_TERNARY_MUL
#endif

#if 1
#define _CBIGNUM_SHIFTTAB_MUL
#endif

#if 1
#define _CBIGNUM_SHIFTTAB_DIV
#endif

#if 0
#define _CBIGNUM_REDUCE_JUMPS
#endif

//================================================
//      Настройка автоматической оптимизации.
//================================================
//      _CBNL_TAB_MIN           минимальный размер множителя, при котором
//                              надо строить таблицу сдвигов множимого
//                              или
//                              минимальная разность размеров делимого и
//                              делителя, при котором надо строить
//                              таблицу сдвигов делителя.
//
//      _CBNL_TAB_OPT           оптимальный размер кусочка множимого
//                              при блочном умножении со сдвигом,
//                              когда неприменим метод Карацубы;
//                              лучше всего брать число 8n - 3.
//
//      _CBNL_TAB_HIGH          максимальный размер кусочка множимого
//                              при блочном умножении со сдвигом,
//                              когда неприменим метод Карацубы.
//
//      _CBNL_TAB_MAX           максимальный размер делителя, при котором
//                              можно строить его таблицу сдвигов.
//
//      _CBNL_MUL_OPT           оптимальный размер кусочка множимого
//                              при аппаратном блочном умножении,
//                              когда неприменим метод Карацубы;
//                              лучше всего брать число 8n - 3.
//
//      _CBNL_MUL_HIGH          максимальный размер кусочка множимого
//                              при аппаратном блочном умножении,
//                              когда неприменим метод Карацубы.
//
//      _CBNL_KARATSUBA_MIN     минимальный размер операндов для их
//                              умножения по методу Карацубы.
//
//      Под размером понимается число слов CBNL в коде числа.

#define _CBNL_TAB_MIN   (3)
#define _CBNL_TAB_OPT   (((sizeof(size_t))<=2? 120: 7680)/\
                         (sizeof (CBNL) * sizeof (CBNL)) - 3)
#define _CBNL_TAB_HIGH  (_CBNL_TAB_OPT + _CBNL_TAB_OPT / 2)
#define _CBNL_TAB_MAX   ((EXSIZE_T_MAX & (size_t)0xFFFFFFFFUL)/\
                         (256 * sizeof (CBNL) * sizeof (CBNL)))

#ifndef _CBIGNUM_HARDWARE_MUL
#define _CBNL_KARATSUBA_MIN     (100)
#else
#define _CBNL_KARATSUBA_MIN     (50)
#define _CBNL_MUL_OPT   (7680 / sizeof (CBNL) - 3)
#define _CBNL_MUL_HIGH  (_CBNL_MUL_OPT + _CBNL_MUL_OPT / 2)
#endif//_CBIGNUM_HARDWARE_MUL

#endif//_CBIGNUMF_H
