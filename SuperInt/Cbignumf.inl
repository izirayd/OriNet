/* --------------------------------------------------------------
    Целые числа с неограниченной разрядной сеткой (версия 2.0).
    Базовые функции в машинно-независимом варианте.

    http://www.imach.uran.ru/cbignum

    Copyright 1999-2010, Р.Н.Шакиров, ИМаш УрО PAH.
    All Rights Reserved.

    Код предоставляется на условиях лицензии "public domain",
    т.е. допускается свободное применение, модификация и
    распространение кода при условии сохранения копирайта
    и добавления сведений о всех внесенных изменениях.

    ДАННОЕ ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ "КАК ЕСТЬ"
    БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ, ЯВНЫХ ИЛИ ПОДРАЗУМЕВАЕМЫХ. ВЫ
    ИСПОЛЬЗУЕТЕ ЕГО НА СВОЙ СОБСТВЕННЫЙ СТРАХ И РИСК. АВТОР
    НЕ БУДЕТ НЕСТИ ОТВЕТСТВЕННОСТЬ ЗА УТРАТУ ДАННЫХ, УЩЕРБ,
    УБЫТКИ ИЛИ ЛЮБЫЕ ДРУГИЕ ВИДЫ ПОТЕРЬ ПРИ ЛЮБЫХ СПОСОБАХ
    ИСПОЛЬЗОВАНИЯ ДАННОГО ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ.
-------------------------------------------------------------- */
#ifndef _CBIGNUMF_INL
#define _CBIGNUMF_INL

#ifndef _CBIGNUMF_H
#include "Cbignumf.h"
#endif//_CBIGNUMF_H

#include <assert.h>
#include <limits.h>
#include <stdlib.h>
#define DISALLOW_EXARRAY_SHORTTYPE
#include "Cbignum.h"
#define BITS    (CHAR_BIT * sizeof (CBNL))

static int count_floor2nBITS()
{
  int n = 2; while (n <= (BITS-1)/2) n <<= 1;
  return n;
}
static int floor2nBITSm1 = count_floor2nBITS() - 1;

#ifdef  _MSC_VER
#pragma auto_inline (off)
#endif/*_MSC_VER*/

//================================================
//      Включение оптимизации Cbignumf.cpp.
//================================================
//      _CBIGNUM_OPTIMIZED_COPY копирование.

#ifdef  _CBIGNUM_ASM

#if 1
#define _CBIGNUM_OPTIMIZED_COPY
#endif

#endif//_CBIGNUM_ASM

//================================================
//      Служебные функции.
//================================================

inline size_t size_max (size_t n1, size_t n2)
{
  return ((n1 > n2)? n1 : n2);
}

inline size_t size_min (size_t n1, size_t n2)
{
  return ((n1 < n2)? n1 : n2);
}

//================================================
//      Внешние ссылки объявлены, как "C", чтобы
//      заблокировать преобразование имен.
//      Это позволяет переносить объектные модули
//      между различными версиями трансляторов.
//================================================

#ifdef  NCHECKPTR
#ifdef  __cplusplus
extern "C" {
#endif//__cplusplus
#endif//NCHECKPTR

//================================================
//      Реализация операций над числами cBigNumber.
//================================================
//      Неограниченное целое число хранится в массиве типа CBNL.
//      Элемент массива с нулевым индексом содержит число CBNL-слов,
//      требуемых для представления неограниченного числа в
//      дополнительном двоичном коде, в последующих элементах
//      содержится код числа в порядке от младших разрядов к
//      старшим. Знак числа находится в последнем слове.
//
//      Операции реализованы в виде функций языка C.
//      Неограниченные числа передаются через макро EXPTR(CBNL):
//      это CBNL* в рабочем режиме и exptr<CBNL> в отладочном
//      режиме с проверкой выхода индекса за границы массива.
//      Входные числа объявляются с модификатором const.
//
//      Ряд функции по соображениям оптимизации не заполняют
//      поле числа слов в результирующем числе; вместо этого
//      число слов выдается в качестве значения типа size_t.
//      Имена таких функций начинаются со знака подчеркивания;
//      они сопровождаются inline-функцией, вызывающе функцию
//      и заполняющей поле числа слов.
//
//      Динамический контроль входных данных
//      управляется следующими макросами:
//      NDEBUG    - отключает контроль выхода указателя
//                  за границы массива и контроль ошибок
//                  во входных параметрах функций.
//                  выхода указателя за границы массива
//      NCHECKPTR - отключает контроль выхода указателя
//                  за границы массива.
//
//      Циклы в функциях cBigNumber... оптимизированы
//      с тем, чтобы сократить число проверок и переходов
//      при обработке однословных чисел.
//      Порядок выполнения операций выбран, исходя
//      из соображений оптимальной загрузки конвейеров
//      процессора Pentium.

//================================================
//      Диагностические переменные и функции.
//================================================

cTTY    cBigNumberMessages;             // Обработчик сообщений.
cTTY    cBigNumberProgress;             // Обработчик прогресс - индикаторов.

//      Вывод внутреннего представления выполняется в порядке
//      от старших слов к младшим. Каждое слово предваряется
//      пробелом и выводится в шестнадцатеричном представлении,
//      в порядке от старших разрядов к младшим.
//      Вывод числа завершается переводом строки.

void    cBigNumberDump (                        // Вывод кода в сообщения.
                const   CBPTR(CBNL) p1          // Неограниченное число.
        )
{
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  for (; n1; n1--) cBigNumberMessages <<" "<< (const char*) cHexDump (p1 [n1]);
  cBigNumberMessages << "\n";
}

//      Короткий дамп содержит старшее слово в шестнадцатеричном
//      представлении и число и число байт.
//      the high word followed by total number of words.

void    cBigNumberInfo (                        // Информация (короткий дамп).
                const   CBPTR(CBNL) p1          // Неограниченное число.
        )
{
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  cBigNumberMessages << cHexDump (n1? p1 [n1]: 0);
  if (n1 > 1)
    cBigNumberMessages << "... (" << (CBNL)(n1 * sizeof (CBNL)) << " bytes)\n";
}

void    cBigNumberERange  (                     // Сообщение об ошибке.
                const   CBPTR(CBNL) p1          // Неограниченное число.
        )
{
  cBigNumberMessages << "cBigNumber value out of range: ";
  cBigNumberInfo (p1);
  abort();
}

//================================================
//      Информационные функции.
//================================================

//      Значащими считаются самое старшие слово, содержащее не
//      только знаковый бит и биты его расширения и все младшие
//      по отношению к нему слова.

size_t  cBigNumberWords (                       // Число значащих слов.
                const   CBPTR(CBNL) p1          // Неограниченное число.
        )                                       // Возможно, ненормализованное.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  if (n1)
  {
    CBNL sign = p1 [n1] >> (BITS-1);            // Знак 0 или -1.
    do
    {
      if (p1 [n1] != sign) break;               // Есть значащие биты?
    }
    while (--n1 != 0);
  }
  return (n1);
}

//      В числе со знаком значащими считаются самый старший бит,
//      отличный от знакового бита и все младшие по отношению к нему
//      биты. Например, у 0 и -1 нет значащих битов, 1 и -2 имеют
//      1 значащий бит, числа 127 и -128 имеют 7 значащих бит.
//      Модуль числа с n значащими битами не превосходит 2 в
//      степени n.

int     cLongBits (CBNL num)                    // Число значащих бит
{                                               // в диапазоне 0..BITS-1.
  int n = 0;
  num ^= (num >> (BITS-1));                     // Отрицательное число.
  int k = floor2nBITSm1;                        // Сдвиг ..15,7,3,1.
  do
  {
    int k0 = (((num >> k) == 0) - 1) & (k + 1); num >>= k0; n += k0;
  }
  while ((k >>= 1) != 0);
  return (n += (num > 0));                      // Сдвиг 0.
}

//      В числе без знака значащими считается самый старший бит,
//      отличный от 0 и все младшие по отношению к нему биты.

int     cULongBits (unsigned CBNL num)          // Число значащих бит
{                                               // в диапазоне 0..BITS.
  int n = (((CBNL)num >= 0) - 1); num &= ~n;
      n &= BITS;                                // BITS значащих битов.
  int k = floor2nBITSm1;                        // Сдвиг ..15,7,3,1.
  do
  {
    int k0 = (((num >> k) == 0) - 1) & (k + 1); num >>= k0; n += k0;
  }
  while ((k >>= 1) != 0);
  return (n += (num > 0));                      // Сдвиг 0.
}

//      Подсчет значащих битов в неограниченном числе.
//      Если их число > CBNL_MAX вызывается cBigNumberERange().

CBNL    cBigNumberBits (                        // Число значащих бит.
                const   CBPTR(CBNL) p1          // Неограниченное число.
        )                                       // Возможно, ненормализованное.

{
  size_t n = cBigNumberWords(p1);               // Число значащих слов.
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  if (n)
  {                                             // Проверка переполнения.
    if ((CBNL)n > (CBNL)(CBNL_MAX / BITS))
       cBigNumberERange (p1);
    return ((CBNL)(n - 1) * BITS + cULongBits ((unsigned CBNL)
                                    (p1 [n] ^ (p1 [n1] >> (BITS-1)))));
  }
  return (0);
}

//      К младшим 0-словам относятся все значащие слова,
//      младшие по отношению к младшему ненулевому слову.
//      Если все слова нулевые, то младших 0-слов нет.

size_t  cBigNumberExWords (                     // Число младших 0-слов.
                const   CBPTR(CBNL) p1          // Неограниченное число.
)                                               // Возможно, ненормализованное.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  for (size_t n = 0; n < n1; n++)
  {
    if (p1 [n + 1] != 0) return (n);            // Число 0-слов.
  }
  return (0);
}

//      К младшим 0-битам относятся все значащие биты,
//      младшие по отношению к младшему ненулевому биту.
//      Например, у 0 и нечетных чисел нет младших 0-битов,
//      2 и -2 имеют 1 младший бит, 128 и -128 имеют
//      7 младших 0-битов. Модуль числа с n младшими
//      0-битами не меньше 2 в степени n.

int     cLongExBits (CBNL num)                  // Число младших 0-битов
{                                               // в диапазоне 0..BITS-1.
  int n = 0;
  if (num) while ((num & (CBNL)1) == 0) { ++n; num >>= 1; }
  return (n);
}

//      Подсчет младших 0-битов в неограниченном числе.
//      Если их число больше > CBNL_MAX вызывается cBigNumberERange().

CBNL    cBigNumberExBits (                      // Число младших 0-битов.
                const   CBPTR(CBNL) p1          // Неограниченное число.
        )                                       // Возможно, ненормализованное.

{
  size_t n = cBigNumberExWords(p1);             // Число младших 0-слов.
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  if (n1)
  {                                             // Проверка переполнения.
    if ((CBNL)n > (CBNL)((CBNL_MAX - (BITS - 1)) / BITS))
      cBigNumberERange (p1);
    return ((CBNL)n * BITS + cLongExBits (p1 [n + 1]));
  }
  return (0);
}

//      Проверка числа на положительность и равенство 2 в степени n.

int     cLongExactLog2 (CBNL num)               // Точный log2 или -1.
{                                               // log2 в диапазоне 0..BITS-1.
  int n = cLongExBits (num);
  if ((num >> n) != 1) n = -1;
  return n;
}

//================================================
//      Нормализация и денормализация.
//================================================

//      Число является нормализованным, если для записи дополнительного
//      кода используется минимально возможное число CBNL-слов, но не
//      менее одного слова:
//      - если число слов больше 1, то старшее слово отличается от
//        результата расширения старшего бита предпоследнего слова;
//      - нуль представляется одним нулевым словом.

size_t _CBNL_C  cBigNumberIsFit (               // Проверка нормализованности.
                const   CBPTR(CBNL) p1          // Неограниченное число.
        )                                       // Если число нормализованное,
{                                               // то выдает 1 иначе 0.
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.

  if (n1 > 1) return ((p1 [n1] != (p1 [n1-1] >> (BITS-1))));

  return (n1);                                  // Число слов 1 или 0.
}

//      Нормализация к минимальному числу слов,
//      потребному для хранения числа (не менее 1).

size_t _CBNL_C _cBigNumberFit (                 // Нормализация.
                        EXPTR(CBNL) p1          // Буфер с числом.
        )                                       // Размер буфера >= 2.
{
  register size_t n1 = (size_t)(*p1);           // Число слов.
  p1 += n1;                                     // Подготовка указателя.

  if (n1)                                       // Если в старшем слове и в
  {                                             // старшем бите предыдущего
    register CBNL pass, lp = *p1;               // слова все 0 или все 1, то
    do continue;                                // удаляется старшее слово.
    while (--n1 != 0 &&
        (pass = lp, lp = p1 [-1], --p1, pass == (lp >> (BITS-1))));
  }                                             // Если ни одного слова нет,
  else { p1 [1] = 0; }                          // добавляется нулевое слово.

  return (n1 + 1);                              // Число слов.
}
//#define cBigNumberFit(p1)     (size_t)(*(p1)=_cBigNumberFit(p1))

//      Денормализация с увеличением числа слов до заданной
//      величины. Если заданная величина не больше исходного
//      числа слов, то число слов увеличивается на 1.
//
//      Функция выдает НЕ нормализованный результат.

size_t _CBNL_C _cBigNumberFitTo (               // Денормализация.
                        EXPTR(CBNL) p1,         // Буфер с числом.
                        size_t      n           // Число слов.
        )                                       // Размер буфера не менее
{                                               // max (*p1 + 2, n + 1).
  register size_t n1 = (size_t)(*p1);           // Число слов.
  register CBNL pass = p1 [n1] >> (BITS-1);     // Перенос.

  do
    p1 [++n1] = pass;                           // Распространяем перенос.
  while (n1 < n);

  return (n1);                                  // Число слов.
}
//#define cBigNumberFitTo(p1,n) (size_t)(*(p1)=_cBigNumberFitTo(p1,n))

//================================================
//      Функции сравнения.
//================================================

//      Длина чисел уравнивается путем расширения
//      знакового разряда более короткого числа.
//      Полученные слова сравниваются пословно в порядке
//      от старших слов к младшим до первого несовпадения.
//      Сравнение старших слова - знаковое, сравнение
//      остальных слов - беззнаковое.

//      Для целей оптимизации вместо фактического расширения
//      знакового разряда применяется алгоритмический эквивалент.

int    _CBNL_C  cBigNumberComp (                // Сравнение p1, p2.
                const   CBPTR(CBNL) p1,         // Число.
                const   CBPTR(CBNL) p2          // Число.
        )                                       // Выдает -1 при p1 <  p2
                                                // Выдает  0 при p1 == p2
                                                // Выдает  1 при p1  > p2
{                                               // p1, p2 могут совпадать.
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов в p1.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов в p2.
  register CBNL lp1 = 0;                        // Текущее слово p1.
  register CBNL lp2 = 0;                        // Текущее слово p2.

//      Сравнение знаковых слов.

  if (n1) lp1 = p1 [n1--];                      // Знаковое слово p1.
  if (n2) lp2 = p2 [n2--];                      // Знаковое слово p2.

  if (n1 == n2)                                 // Длины p1, p2 совпадают.
  {
    if (lp1 != lp2) goto NotSameSignWord;       // Знаковые слова не совпадают.
  }
  else if (n1 > n2)                             // Если число p1 длиннее, то
  {                                             // проводится сравнение с
    lp2 >>= (BITS-1); ++n2;                     // расширением знака p2.
    if (lp1 != lp2) goto NotSameSignWord;       // Знаковые слова не совпадают.
    if (n1 > n2)                                // Сравнение незнаковых слов.
    {
      do                                        // Цикл сравнения.
      {
        lp1 = p1 [n1]; --n1;                    // Чтение слова.
        if (lp1 != lp2) goto NotSame;           // Слова не совпадают.
      }
      while (n1 > n2);                          // Конец цикла сравнения.
    }
  }
  else // (n1 < n2)                             // Если число p2 длиннее, то
  {                                             // проводится сравнение с
    lp1 >>= (BITS-1); ++n1;                     // расширением знака p1.
    if (lp1 != lp2) goto NotSameSignWord;       // Знаковые слова не совпадают.
    if (n1 < n2)                                // Сравнение незнаковых слов.
    {
      do                                        // Цикл сравнения.
      {
        lp2 = p2 [n2]; --n2;                    // Чтение слова.
        if (lp1 != lp2) goto NotSame;           // Слова не совпадают.
      }
      while (n1 < n2);                          // Конец цикла сравнения.
    }
  }

//      Попарное сравнение незнаковых слов.

  if (n1)
  {
    do                                          // Цикл сравнения.
    {
      lp1 = p1 [n1]; lp2 = p2 [n1]; --n1;       // Чтение слова.
      if (lp1 != lp2) goto NotSame;             // Слова не совпадают.
    }
    while (n1);                                 // Конец цикла сравнения.
  }

  return (0);                                   // Значения совпадают.
NotSame:                                        // Значения не совпадают.
  return (((unsigned CBNL)lp1 >= (unsigned CBNL)lp2) * 2 - 1);
NotSameSignWord:                                // Не совпадают знаковые слова.
  return ((lp1 >= lp2) * 2 - 1);
}

//      Специальное сравнение для деления.
//      Предполагается, что:
//      - числа нормализованы.
//      - размер первого числа не меньше размера второго числа.
//      Перед cравнением второе число сдвигается влево до совпадения размеров.

int    _CBNL_C  cBigNumberCompHigh (            // Сравнение от старших слов.
                const   CBPTR(CBNL) p1,         // Число.
                const   CBPTR(CBNL) p2          // Число.
        )                                       // Выдает -1 при p1 <  p2
                                                // Выдает  0 при p1 == p2
                                                // Выдает  1 при p1  > p2
{                                               // p1, p2 могут совпадать.
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов в p1.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов в p2.
  assert (n1 >= n2);                            // Проверка размера.
  assert (n2 > 0);                              // Проверка размера.

  register CBNL lp1 = p1 [n1--];                // Текущее слово p1.
  register CBNL lp2 = p2 [n2--];                // Текущее слово p2.
  assert (!n1 || lp1 != (p1 [n1] >> (BITS-1))); // Проверка нормализованности.
  assert (!n2 || lp2 != (p2 [n2] >> (BITS-1))); // Проверка нормализованности.

//      Сравнение знаковых слов.

  if (lp1 != lp2) return ((lp1 > lp2) * 2 - 1); // Слова не совпадают.

//      Попарное сравнение незнаковых слов.

  if (n2)
  do                                            // Цикл сравнения.
  {
    lp1 = p1 [n1--]; lp2 = p2 [n2--];           // Чтение слов.
    if (lp1 != lp2)                             // Слова не совпадают.
      return (((unsigned CBNL)lp1 > (unsigned CBNL)lp2) * 2 - 1);
  }
  while (n2);                                   // Конец цикла сравнения.

//      Сравнение по зоне сдвига.

  if (n1)
  do
  {
    if (p1 [n1--] != 0) return 1;               // Несовпадение.
  }
  while (n1);

  return (0);                                   // Значения совпадают.
}

//      Специальное быстрое сравнение числа c 0.
//
//      Алгоритм оптимизирован для исключения условных переходов.
//      Выдается побитовая сумма знакового слова с числом слов,
//      поделенным на 2 (у положительного числа знаковое
//      слово может быть нулевым, но тогда число слов > 1).
//
//      Предполагается что в числе нет лишних старших 0-слов
//      иначе возможен ложноотрицательный результат.

inline  CBNL    cBigNumberNot0  (               // Сравнение с 0:
                const CBPTR(CBNL) p1_debug      // выдает 0 при p1 == 0
                )                               // иначе отлично от 0.
{
  const CBNL* p1 = CBPTRBASE(p1_debug);         // Обычный указатель.
  size_t n1 = (size_t)(*p1);                    // Число слов.
  return (p1 [n1] | (*p1 >> 1));
}

//================================================
//      Копирования и побитовой инверсии.
//================================================

#ifndef _CBIGNUM_OPTIMIZED_COPY                 // Если не в Cbignumf.cpp.

//      Точное копирование.
//
//      Функция не требует нормализации операнда и не проводит
//      нормализацию результата, но выдает нормализованный
//      результат в случае, если операнд нормализован.

void   _CBNL_C  cBigNumberCopy (                // Копирование p = p1.
                const   CBPTR(CBNL) p1,         // Копируемое число.
                        EXPTR(CBNL) p           // Буфер размера *p1 + 1.
        )                                       // p1, p могут совпадать.
{
  size_t n1 = (size_t)(*p++ = *CBPTRBASE(p1++));// Число слов.
  if (n1)
  {
    do                                          // Цикл копирования слов.
      { *p++ = *p1++; }                         // Копирование слова.
    while (--n1 != 0);                          // Конец цикла копирования.
  }
}

#endif//_CBIGNUM_OPTIMIZED_COPY

//      Побитовая инверсия.
//
//      Функция не требует нормализации операнда и не проводит
//      нормализацию результата, но выдает нормализованный
//      результат в случае, если операнд нормализован.

void    cBigNumberCompl (                       // Инверсия p = ~p1.
                const   CBPTR(CBNL) p1,         // Инвертируемое число.
                        EXPTR(CBNL) p           // Буфер размера
                                                // max (*p1 + 1, 2).
        )                                       // p1, p могут совпадать.
{
  size_t n1 = (size_t)(*p++ = *CBPTRBASE(p1++));// Число слов.
  if (n1)
  {
    do                                          // Цикл инверсии слов.
      { *p++ = ~*p1++; }                        // Инверсия слова.
    while (--n1 != 0);                          // Конец цикла инверсии.
  }
  else
  {
    p [-1] = 1; p [0] = ~(CBNL)0;               // Число ~0.
  }
}

//================================================
//      Функции сдвига на заданное число слов.
//================================================

//      Сдвиг влево сопровождается увеличением числа слов,
//      если только сдвигаемое слово не равно 0.
//      Сдвиг эквивалентен умножению на 2 в степени (BITS * k1).
//
//      Функция не требует нормализации операнда и не проводит
//      нормализацию результата, но выдает нормализованный
//      результат в случае, если операнд нормализован.

void    cBigNumberCopyShl (                     // Сдвиг p = p1 << (BITS*k1).
                const   CBPTR(CBNL) p1,         // Сдвигаемое число.
                        size_t      k1,         // Показатель сдвига в словах.
                        EXPTR(CBNL) p           // Буфер размера
                                                // max (*p1 + k1, 1) + 1.
        )                                       // p1, p могут совпадать.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  if (n1 <= 1 && p1 [n1] == 0) k1 = 0;          // Нулевое число.
  p1 += n1; *p = (CBNL)(n1 + k1); p += (n1 + k1);
  if (n1)
  do                                            // Цикл копирования слов.
    { *p-- = *p1--; }                           // Копирование слова.
  while (--n1 != 0);                            // Конец цикла копирования.
  if (k1)
  do                                            // Цикл обнуления слов.
    { *p-- = 0; }                               // Обнуление слова.
  while (--k1 != 0);                            // Конец цикла обнуления.
}

//      Сдвиг вправо выполняется с сохранением знака числа.
//      Сдвиг эквивалентен делению на 2 в степени (BITS * k1).
//
//      Функция не требует нормализации операнда и не проводит
//      нормализацию результата, но выдает нормализованный
//      результат в случае, если операнд нормализован.

void    cBigNumberCopyShr (                     // Сдвиг p = p1 >> (BITS*k1).
                const   CBPTR(CBNL) p1,         // Сдвигаемое число.
                        size_t      k1,         // Показатель сдвига в словах.
                        EXPTR(CBNL) p           // Буфер размера
                                                // max (*p1 - k1, 1) + 1.
        )                                       // p1, p могут совпадать.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  if (n1 > k1)
  {
    *p++ = (CBNL)(n1 -= k1);                    // Число слов.
    p1 += (k1 + 1);                             // Сдвиг.
    do                                          // Цикл копирования слов.
      { *p++ = *p1++; }                         // Копирование слова.
    while (--n1 != 0);                          // Конец цикла копирования.
  }
  else
  {
    *p = 1; p [1] = p1 [n1] >> (BITS-1);        // Число 0 или -1.
  }
}

//      Вырезка заданного числа слов из числа с добавлением старшего 0-слова.
//
//      Функция выдает НЕ нормализованный результат.

void    cBigNumberCutOut (                      // Вырезка.
                const   CBPTR(CBNL) p1,         // Копируемое число.
                        size_t      k1,         // Начальная позиция.
                        size_t      n,          // Число слов.
                        EXPTR(CBNL) p           // Буфер размера n1 + 1.
        )                                       // p1, p могут совпадать.
{
  assert ((size_t)(*CBPTRBASE(p1)) >= k1 + n);  // Проверка размера.
  *p++ = (CBNL)(n + 1);                         // Число слов.
  if (n > 0)                                    // Требуется копирование.
  {
    p1 += (k1 + 1);                             // Начало.
    do                                          // Цикл копирования слов.
      { *p++ = *p1++; }                         // Копирование слова.
    while (--n != 0);                           // Конец цикла копирования.
  }
  *p = 0;                                       // Старшее слово.
}

//================================================
//      Унарные операции.
//================================================

//      Смена знака делается путем побитовой инверсии и прибавления 1.
//      1) Меняем знак слов вплоть до первого ненулевого результата.
//      2) Инвертируем последующие слова.
//      3) Если последующих слов нет, а старшее слово равно 100..(побитово),
//         то добавить нулевое слово.
//         Если два старших слова результата равны 11.. и 100..(побитово),
//         то удалить старшее слово.
//
//      Функция не требует нормализации операнда и не проводит
//      нормализацию результата, но выдает нормализованный
//      результат в случае, если операнд нормализован.

size_t _CBNL_C _cBigNumberNeg (                 // Смена знака p = -p1.
                const   CBPTR(CBNL) p1,         // Исходное число.
                        EXPTR(CBNL) p           // Буфер размера *p1 + 2.
        )                                       // p1, p могут совпадать.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1++));       // Число слов.
  p++;
  size_t n = n1;                                // Счетчик слов.
  if (n)
  do                                            // Цикл смены знака.
  {
    CBNL lp;                                    // Оптимизация слова.
    if ((*p = lp = -*p1) != 0)                  // Смена знака.
    {                                           // Получено ненулевое слово.
      if (--n != 0)                             // Есть еще слова?
      {                                         // Если слова есть:
        do                                      // Цикл инверсии.
          { ++p1; ++p; *p = lp = ~*p1; }        // Побитовая инверсия слова.
        while (--n != 0);                       // Конец цикла инверсии.
        return (n1 - (lp == (p [-1] >> (BITS-1))));
      }                                         // Старшее слово лишнее?
                                                // Если больше слов нет, то
      if (lp != CBNL_MIN) return (n1);          // проверка переполнения и
      p [1] = 0; return (n1 + 1);               // добавление старшего слова.
    }
  }
  while ((++p1, ++p, --n) != 0);                // Конец цикла смены знака.

  return (n1);                                  // Все слова нулевые.
}
//#define cBigNumberNeg(p1,p)   (size_t)(*(p)=_cBigNumberNeg(p1,p))

//      Прибавление 1:
//      1) Прибавлять к словам 1 вплоть до первого ненулевого результата.
//      2) Если последующих слов нет, а старшее слово равно 100..(побитово),
//         то добавить нулевое слово.
//         Если два старших слова результата равны 11.. и 100..(побитово),
//         то удалить старшее слово.
//
//      Функция не требует нормализации операнда и не проводит
//      нормализацию результата, но выдает нормализованный
//      результат в случае, если операнд нормализован.

size_t  _cBigNumberMInc (                       // Сложение p1 = p1 + 1.
                        EXPTR(CBNL) p1          // Буфер размера *p1 + 2.
        )
{
  size_t n1 = (size_t)(*p1++);                  // Число слов.
  size_t n = n1;                                // Счетчик слов.

  if (n)                                        // Есть хотя бы одно слово.
  {
    do                                          // Цикл прибавления 1.
    {
      CBNL lp;                                  // Оптимизация слова.
      if ((*p1 = lp = *p1 + 1) != 0)            // Прибавление 1.
      {                                         // Получено ненулевое слово.
        if (--n != 0)                           // Есть еще слова?
        {                                       // Если осталось 1 слово
          if (--n != 0) return (n1);            // и оно лишнее, то удаление.
          return (n1 - (p1 [1] == (lp >> (BITS-1))));
        }                                       // Если больше слов нет, то
        if (lp != CBNL_MIN) return (n1);        // проверка переполнения и
        p1 [1] = 0; return (n1 + 1);            // добавление старшего слова.
      }
    }
    while ((++p1, --n) != 0);                   // Конец цикла прибавления 1.
  }
  else { *p1 = 1; n1 = 1; }                     // Нормализация пустого числа.

  return (n1);                                  // Все слова нулевые.
}
//#define cBigNumberMInc(p1)    (size_t)(*(p1)=_cBigNumberMInc(p1))

//      Вычитание 1:
//      1) Вычитать из слов 1 вплоть до первого результата, отличного от ~0.
//      2) Если последующих слов нет, а старшее слово равно 011..(побитово),
//         то добавить единичное слово.
//         Если два старших слова результата равны 00.. и 011..(побитово),
//         то удалить старшее слово.
//
//      Функция не требует нормализации операнда и не проводит
//      нормализацию результата, но выдает нормализованный
//      результат в случае, если операнд нормализован.

size_t  _cBigNumberMDec (                       // Вычитание p1 = p1 - 1.
                        EXPTR(CBNL) p1          // Буфер размера *p1 + 2.
        )
{
  size_t n1 = (size_t)(*p1++);                  // Число слов.
  size_t n = n1;                                // Счетчик слов.

  if (n)                                        // Есть хотя бы одно слово.
  {
    do                                          // Цикл вычитания 1.
    {
      CBNL lp;                                  // Оптимизация слова.
      if ((*p1 = lp = *p1 - 1) != ~(CBNL)0)     // Вычитание 1.
      {                                         // Получено неединичное слово.
        if (--n != 0)                           // Есть еще слова?
        {                                       // Если осталось 1 слово
          if (--n != 0) return (n1);            // и оно лишнее, то удаление.
          return (n1 - (p1 [1] == (lp >> (BITS-1))));
        }                                       // Если больше слов нет, то
        if (lp != CBNL_MAX) return (n1);        // проверка переполнения и
        p1 [1] = ~(CBNL)0; return (n1 + 1);     // добавление старшего слова.
      }
    }
    while ((++p1, --n) != 0);                   // Конец цикла вычитания 1.
  }
  else { *p1 = -1; n1 = 1; }                    // Нормализация пустого числа.

  return (n1);                                  // Все слова единичные.
}
//#define cBigNumberMDec(p1)    (size_t)(*(p1)=_cBigNumberMDec(p1))

//      Сдвиг влево выполняется последовательно с переносом
//      старшего разряда в последующее слово и формированием
//      еще одного слова, полученного расширением знакового
//      разряда старшего слова. Если два последних разряда
//      старшего слова не совпадают, то размер числа увеличивается
//      на 1, т.е. добавленное слово становится знаковым.
//
//      Функция не требует нормализации операнда и не проводит
//      нормализацию результата, но выдает нормализованный
//      результат в случае, если операнд нормализован.

size_t  _cBigNumberMMul2 (                      // Сдвиг p1 <<= 1.
                        EXPTR(CBNL) p1          // Буфер размера *p1 + 2.
        )
{
  size_t n1 = (size_t)(*p1++);                  // Число слов.
  size_t n = n1;                                // Счетчик слов.
  CBNL num = 0;                                 // Слово до сдвига.
  if (n)
  do                                            // Цикл сдвига слов.
  {
    CBNL pass = (unsigned CBNL)num >> (BITS-1); // Разряд из предыдущего слова.
    num = *p1;                                  // Текущее слово до сдвига.
    *p1++ = (num << 1) | pass;                  // Текущее слово после сдвига.
  }
  while (--n != 0);                             // Конец цикла сдвига слов.

  num >>= (BITS-2);                             // Расширение знака
  n1 += (num != (*p1 = num >> 1));              // при переполнении.

  return (n1);                                  // Число слов.
}
//#define cBigNumberMMul2(p1)   (size_t)(*(p1)=_cBigNumberMMul2(p1))

//      Вариант сдвига влево с копированием.

size_t  _cBigNumberMul2 (                       // Сдвиг p = p1 << 1.
                const   CBPTR(CBNL) p1,         // Операнд.
                        EXPTR(CBNL) p           // Буфер размера *p1 + 2.
        )
{
  size_t n1 = (size_t)(*CBPTRBASE(p1++));       // Число слов.
  p++;
  CBNL num = 0;                                 // Слово до сдвига.
  size_t n = n1;                                // Счетчик слов.

  if (n)
  do                                            // Цикл сдвига слов.
  {
    CBNL pass = (unsigned CBNL)num >> (BITS-1); // Разряд из предыдущего слова.
    num = *p1++;                                // Текущее слово до сдвига.
    *p++ = (num << 1) | pass;                   // Текущее слово после сдвига.
  }
  while (--n != 0);                             // Конец цикла сдвига слов.

  num >>= (BITS-2);                             // Расширение знака
  n1 += (num != (*p = num >> 1));               // при переполнении.

  return (n1);                                  // Число слов.
}
//#define cBigNumberMul2(p1,p)  (size_t)(*(p)=_cBigNumberMul2(p1,p))

//      Сдвиг вправо выполняется последовательно с переносом
//      младшего разряда в предыдущее слово.
//      Сдвиг старшего слова знаковый, остальных - беззнаковый.
//      Если до сдвига все разряды старшего слова совпадают,
//      то старшее слово результата удаляется.
//
//      Функция не требует нормализации операнда и не проводит
//      нормализацию результата, но выдает нормализованный
//      результат в случае, если операнд нормализован.

size_t  _cBigNumberMDiv2 (                      // Сдвиг p1 >>= 1.
                        EXPTR(CBNL) p1          // Буфер размера *p1 + 1.
        )
{
  size_t n1 = (size_t)(*p1);                    // Число слов.
  size_t n = n1;                                // Счетчик слов.
  p1 += n;                                      // Старшее слово.

  if (n)                                        // Есть слова?
  {
    if (--n != 0)                               // Более одного слова.
    {
      CBNL num = *p1;                           // Старшее слово до сдвига.
      n1 -= (num == (*p1-- = (num >> 1)));      // Сдвиг старшего слова и его
                                                // удаление, если 0 или ~0.
      do                                        // Цикл сдвига слов.
      {
        CBNL pass = num << (BITS-1);            // Разряд из следующего слова.
        num = *p1;                              // Текущее слово до сдвига.
        *p1-- = ((unsigned CBNL)num >> 1) | pass;
      }                                         // Текущее слово после сдвига.
      while (--n != 0);                         // Конец цикла сдвига слов.
    }
    else                                        // Только одно слово.
    {
      (*p1) >>= 1;                              // Сдвиг.
    }
  }
  return (n1);                                  // Число слов.
}
//#define cBigNumberMDiv2(p1)   (size_t)(*(p1)=_cBigNumberMDiv2(p1))

//      Вариант сдвига вправо с копированием.

size_t  _cBigNumberDiv2 (                       // Сдвиг p = p1 << 1.
                const   CBPTR(CBNL) p1,         // Операнд.
                        EXPTR(CBNL) p           // Буфер размера *p1 + 1.
        )
{
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  size_t n = n1;                                // Счетчик слов.
  p1 += n;                                      // Старшее слово.
  p  += n;                                      // Старшее слово.

  if (n)                                        // Есть слова?
  {
    if (--n != 0)                               // Более одного слова.
    {
      CBNL num = *p1--;                         // Старшее слово до сдвига.
      n1 -= (num == (*p-- = (num >> 1)));       // Сдвиг старшего слова и его
                                                // удаление, если 0 или ~0.
      do                                        // Цикл сдвига слов.
      {
        CBNL pass = num << (BITS-1);            // Разряд из следующего слова.
        num = *p1--;                            // Текущее слово до сдвига.
        *p-- = ((unsigned CBNL)num >> 1) | pass;// Текущее слово после сдвига.
      }
      while (--n != 0);                         // Конец цикла сдвига слов.
    }
    else                                        // Только одно слово.
    {
      *p = (*p1) >> 1;                          // Сдвиг.
    }
  }
  return (n1);                                  // Число слов.
}
//#define cBigNumberDiv2(p1,p)  (size_t)(*(p)=_cBigNumberDiv2(p1,p))

//================================================
//      Подготовка таблицы сдвигов.
//================================================

//      Число нормализуется, далее в том же буфере после числа
//      формируется таблица сдвигов на 1..BITS-1 с шагом *p + 2.
//      Функция всегда выдает нормализованное число и
//      нормализованные сдвиги; при этом незадействованные старшие
//      слова заполняются расширениями знаковых разрядов.
//      После этого число может участвовать в оптимизированных
//      операциях, использующих таблицу сдвигов.

void    cBigNumberTab (                         // Подготовка таблицы сдвигов.
                        EXPTR(CBNL) p           // Число в буфере размера
        )                                       // (max(*p,1) + 2) * BITS + 1.
                                                // Буфер заполняется сдвигами
{                                               // p << 1..BITS-1, шаг *p + 2.
  size_t n = cBigNumberFit (p);                 // Число нормализованных слов.
  int ns = BITS - 1;                            // Счетчик битовых сдвигов.
  p [n + 1] = p [n] >> (BITS-1);                // Расширение знака.
  n += 2;
  EXPTR(CBNL) pp = p;                           // Рабочий указатель.
  do                                            // Цикл сдвигов.
  {
    pp += n;
    cBigNumberMul2 (p, pp);                     // Сдвиг числа на бит.
    p = pp;
  }
  while (--ns > 0);                             // Конец цикла по словам.
}

//================================================
//      Логические функции.
//================================================

//      Длина чисел уравнивается путем расширения
//      знакового разряда более короткого числа.
//      Полученные слова обрабатываются пословно.
//
//      Особенности реализации:
//      - Предполагается, что второй операнд не длиннее первого.
//      - Для целей оптимизации вместо фактического расширения
//        знакового разряда применяется алгоритмический эквивалент.
//
//      Функции не требуют нормализации операндов и всегда выдают
//      нормализованное число, за исключением случая, когда в операндах
//      нет ни одного слова - тогда результат будет таким же.

size_t  _cBigNumberXor  (                       // Сложение mod2 p = p1 ^ p2.
                const   CBPTR(CBNL) p1,         // Операнд.
                const   CBPTR(CBNL) p2,         // Операнд (не длиннее p1).
                        EXPTR(CBNL) p           // Буфер размера *p1 + 1.
        )                                       // p1, p2, p могут совпадать.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1++));       // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2++));       // Число слов.
  p++;
  assert (n1 >= n2);
  if (n1 == 0) return 0;                        // Возврат, если 0 слов.

  {
    register CBNL lp2 = 0;                      // Текущее слово p2.

//      Обработка слов p1, p2.

    {
      size_t n;                                 // Счетчик слов.
      if ((n = n2) != 0)
      {
        do { *p++ = *p1++ ^ (lp2 = *p2++); }    // Цикл по p1, p2.
        while (--n != 0);                       // Конец цикла по p1, p2.
      }
    }

//      Обработка остатка p1, если p1 длиннее p2.

    {
      lp2 >>= (BITS-1);                         // Знаковый разряд p2.
      size_t n;                                 // Счетчик слов.
      if ((n = n1 - n2) != 0)
      {
        do { *p++ = *p1++ ^ lp2; }              // Цикл по p1.
        while (--n != 0);                       // Конец цикла по p1.
      }
    }
    --p;                                        // Подготовка указателя.
  }

//      Нормализация - удаление лишних старших слов p, состоящих из 0 и 1
//      и совпадающих с расширением знакового разряда предыдущего слова.

  {
    register CBNL pass;                         // Старшее слово.
    register CBNL lp;                           // Предыдущее слово.
    register size_t n = n1;                     // Число слов.
    if (n)                                      // Если в старшем слове и в
    {                                           // старшем бите предыдущего
      lp = *p;                                  // слова все 0 или все 1, то
      do continue;                              // удаляется старшее слово.
      while (--n != 0 &&
        (pass = lp, lp = p [-1], --p, pass == (lp >> (BITS-1))));
    }                                           // Если ни одного слова нет,
    else { p [1] = 0; }                         // добавляется нулевое слово.

    return (n + 1);                             // Число слов p.
  }
}
//#define cBigNumberXor(p1,p2,p) (size_t)(*(p)=_cBigNumberXor(p1,p2,p))

size_t  _cBigNumberAnd  (                       // Конъюнкция p = p1 & p2.
                const   CBPTR(CBNL) p1,         // Операнд.
                const   CBPTR(CBNL) p2,         // Операнд (не длиннее p1).
                        EXPTR(CBNL) p           // Буфер размера *p1 + 1.
        )                                       // p1, p2, p могут совпадать.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1++));       // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2++));       // Число слов.
  p++;
  assert (n1 >= n2);
  if (n1 == 0) return 0;                        // Возврат, если 0 слов.

  {
    register CBNL lp2 = 0;                      // Текущее слово p2.

//      Обработка слов p1, p2.

    {
      size_t n;                                 // Счетчик слов.
      if ((n = n2) != 0)
      {
        do { *p++ = *p1++ & (lp2 = *p2++); }    // Цикл по p1, p2.
        while (--n != 0);                       // Конец цикла по p1, p2.
      }
    }

//      Обработка остатка p1, если p1 длиннее p2.

    {
      lp2 >>= (BITS-1);                         // Знаковый разряд p2.
      size_t n;                                 // Счетчик слов.
      if ((n = n1 - n2) != 0)
      {
        do { *p++ = *p1++ & lp2; }              // Цикл по p1.
        while (--n != 0);                       // Конец цикла по p1.
      }
    }
    --p;                                        // Подготовка указателя.
  }

//      Нормализация - удаление лишних старших слов p, состоящих из 0 и 1
//      и совпадающих с расширением знакового разряда предыдущего слова.

  {
    register CBNL pass;                         // Старшее слово.
    register CBNL lp;                           // Предыдущее слово.
    register size_t n = n1;                     // Число слов.
    if (n)                                      // Если в старшем слове и в
    {                                           // старшем бите предыдущего
      lp = *p;                                  // слова все 0 или все 1, то
      do continue;                              // удаляется старшее слово.
      while (--n != 0 &&
        (pass = lp, lp = p [-1], --p, pass == (lp >> (BITS-1))));
    }                                           // Если ни одного слова нет,
    else { p [1] = 0; }                         // добавляется нулевое слово.

    return (n + 1);                             // Число слов p.
  }
}
//#define cBigNumberAnd(p1,p2,p) (size_t)(*(p)=_cBigNumberAnd(p1,p2,p))

size_t  _cBigNumberOr  (                        // Дизъюнкция p = p1 & p2.
                const   CBPTR(CBNL) p1,         // Операнд.
                const   CBPTR(CBNL) p2,         // Операнд (не длиннее p1).
                        EXPTR(CBNL) p           // Буфер размера *p1 + 1.
        )                                       // p1, p2, p могут совпадать.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1++));       // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2++));       // Число слов.
  p++;
  assert (n1 >= n2);
  if (n1 == 0) return 0;                        // Возврат, если 0 слов.

  {
    register CBNL lp2 = 0;                      // Текущее слово p2.

//      Обработка слов p1, p2.

    {
      size_t n;                                 // Счетчик слов.
      if ((n = n2) != 0)
      {
        do { *p++ = *p1++ | (lp2 = *p2++); }    // Цикл по p1, p2.
        while (--n != 0);                       // Конец цикла по p1, p2.
      }
    }

//      Обработка остатка p1, если p1 длиннее p2.

    {
      lp2 >>= (BITS-1);                         // Знаковый разряд p2.
      size_t n;                                 // Счетчик слов.
      if ((n = n1 - n2) != 0)
      {
        do { *p++ = *p1++ | lp2; }              // Цикл по p1.
        while (--n != 0);                       // Конец цикла по p1.
      }
    }
    --p;                                        // Подготовка указателя.
  }

//      Нормализация - удаление лишних старших слов p, состоящих из 0 и 1
//      и совпадающих с расширением знакового разряда предыдущего слова.

  {
    register CBNL pass;                         // Старшее слово.
    register CBNL lp;                           // Предыдущее слово.
    register size_t n = n1;                     // Число слов.
    if (n)                                      // Если в старшем слове и в
    {                                           // старшем бите предыдущего
      lp = *p;                                  // слова все 0 или все 1, то
      do continue;                              // удаляется старшее слово.
      while (--n != 0 &&
        (pass = lp, lp = p [-1], --p, pass == (lp >> (BITS-1))));
    }                                           // Если ни одного слова нет,
    else { p [1] = 0; }                         // добавляется нулевое слово.

    return (n + 1);                             // Число слов p.
  }
}
//#define cBigNumberOr(p1,p2,p)  (size_t)(*(p)=_cBigNumberOr(p1,p2,p))

//================================================
//      Функции сложения и вычитания.
//================================================

//      Длина чисел уравнивается путем расширения
//      знакового разряда более короткого числа.
//      Полученные слова складываются (вычитаются) пословно с
//      обработкой переносов (займов) из одного слова в другое.
//
//      Особенности реализации:
//      - Предполагается, что второй операнд не длиннее первого.
//      - Для целей оптимизации вместо фактического расширения
//        знакового разряда применяется алгоритмический эквивалент.
//
//      Функции не требуют нормализации операндов и всегда выдают
//      нормализованное число, за исключением случая, когда в операндах
//      нет ни одного слова - тогда результат будет таким же.

size_t  _cBigNumberAdd  (                       // Сложение p = p1 + p2.
                const   CBPTR(CBNL) p1,         // Слагаемое.
                const   CBPTR(CBNL) p2,         // Добавляемое (не длиннее p1).
                        EXPTR(CBNL) p           // Буфер размера *p1 + 2.
        )                                       // p1, p2, p могут совпадать.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1++));       // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2++));       // Число слов.
  p++;
  assert (n1 >= n2);
  if (n1 == 0) return 0;                        // Return if 0 words.

  register unsigned CBNL pass = 0;              // Перенос в следующее слово p.
        // перенос располагается в старшем бите pass
        // unsigned CBNL обеспечивает сдвиг pass >> без расширения знака.
  {
    register CBNL lp1 = 0;                      // Текущее слово p1.
    register CBNL lp2 = 0;                      // Текущее слово p2.

//      Суммирование слов p1, p2.

    {
      size_t n;                                 // Счетчик слов.
      if ((n = n2) != 0)
      {
        do                                      // Цикл по p1, p2.
        {
          lp1 = *p1++; lp2 = *p2++;
          pass = (~(*p++ = (pass >> (BITS-1)) + lp1 + lp2) & (lp1 ^ lp2))
                                                           | (lp1 & lp2);
        }
        while (--n != 0);                       // Конец цикла по p1, p2.
      }
    }

//      Перенос или заем по остатку p1, если p1 длиннее p2.

    {
      size_t n;                                 // Счетчик слов.
      if ((n = n1 - n2) != 0)
      {
        register const CBNL *pp = p1;           // Оптимизация.
        if ((lp2 & CBNL_MIN) == 0)              // p2 неотрицательно.
        {
          do                                    // Цикл по p1.
          {
            lp1 = *pp++;
            pass = ~(*p++ = (pass >> (BITS-1)) + lp1) & lp1;
          }
          while (--n != 0);                     // Конец цикла по p1.
        }
        else                                    // p2 отрицательно.
        {
          do                                    // Цикл по p1.
          {
            lp1 = *pp++;
            pass = ~(*p++ = (pass >> (BITS-1)) + lp1 - 1) | lp1;
          }
          while (--n != 0);                     // Конец цикла по p1.
        }
      }
    }
    --p;                                        // Подготовка указателя.

//      Суммирование расширений знаковых разрядов p1, p2.
//      Полученное таким образом старшее слово p состоит только из 0 или 1.
//      Старшее слово p запоминается в pass.

    pass = (pass >> (BITS-1)) + ((lp1) >> (BITS-1)) + ((lp2) >> (BITS-1));
  }

//      Нормализация - удаление лишних старших слов p, состоящих из 0 и 1
//      и совпадающих с расширением знакового разряда предыдущего слова.

  {
    register CBNL lp = *p;                      // Предыдущее слово.
    register size_t n = n1;                     // Число слов, кроме старшего.
    if (n && (CBNL)pass == (lp >> (BITS-1)))    // Если в старшем слове и в
    {                                           // старшем бите предыдущего
      do continue;                              // слова все 0 или все 1, то
      while (--n != 0 &&                        // удаляется старшее слово.
        (pass = lp, lp = p [-1], --p, (CBNL)pass == (lp >> (BITS-1))));
    }
    else { p [1] = pass; }                      // Запись старшего слова.

    return (n + 1);                             // Число слов p.
  }
}
//#define cBigNumberAdd(p1,p2,p) (size_t)(*(p)=_cBigNumberAdd(p1,p2,p))

//      Операция вычитания реализована в двух вариантах:
//      обычное вычитание и вычитание со сменой знака.

size_t  _cBigNumberSub  (                       // Вычитание p = p1 - p2.
                const   CBPTR(CBNL) p1,         // Вычитаемое.
                const   CBPTR(CBNL) p2,         // Вычитатель (не длиннее p1).
                        EXPTR(CBNL) p           // Буфер размера *p1 + 2.
        )                                       // p1, p2, p могут совпадать.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1++));       // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2++));       // Число слов.
  p++;
  assert (n1 >= n2);
  if (n1 == 0) return 0;                        // Return if 0 words.

  unsigned CBNL pass = ~(unsigned CBNL)0;       // Перенос в следующее слово p.
        // перенос располагается в старшем бите pass
        // unsigned CBNL обеспечивает сдвиг pass >> без расширения знака.
        // начальное значение обеспечивает прибавление единицы.
  {
    register CBNL lp1 = 0;                      // Текущее слово p1.
    register CBNL lp2 = ~(CBNL)0;               // Текущее слово ~p2.

//      Суммирование слов p1, ~p2.

    {
      size_t n;                                 // Счетчик слов.
      if ((n = n2) != 0)
      {
        do                                      // Цикл по p1, p2.
        {
          lp1 = *p1++; lp2 = ~(*p2++);
          pass = (~(*p++ = (pass >> (BITS-1)) + lp1 + lp2) & (lp1 ^ lp2))
                                                           | (lp1 & lp2);
        }
        while (--n != 0);                       // Конец цикла по p1, p2.
      }
    }

//      Перенос или заем по остатку p1, если p1 длиннее p2.

    {
      size_t n;                                 // Счетчик слов.
      if ((n = n1 - n2) != 0)
      {
        register const CBNL *pp = p1;           // Оптимизация.
        if ((lp2 & CBNL_MIN) == 0)              // p2 отрицательно.
        {
          do                                    // Цикл по p1.
          {
            lp1 = *pp++;
            pass = ~(*p++ = (pass >> (BITS-1)) + lp1) & lp1;
          }
          while (--n != 0);                     // Конец цикла по p1.
        }
        else                                    // p2 неотрицательно.
        {
          do                                    // Цикл по p1.
          {
            lp1 = *pp++;
            pass = ~(*p++ = (pass >> (BITS-1)) + lp1 - 1) | lp1;
          }
          while (--n != 0);                     // Конец цикла по p1.
        }
      }
    }
    --p;                                        // Подготовка указателя.

//      Суммирование расширений знаковых разрядов p1, p2~.
//      Полученное таким образом старшее слово p состоит только из 0 или 1.
//      Старшее слово p запоминается в pass.

    pass = (pass >> (BITS-1)) + ((lp1) >> (BITS-1)) + ((lp2) >> (BITS-1));
  }

//      Нормализация - удаление лишних старших слов p, состоящих из 0 и 1
//      и совпадающих с расширением знакового разряда предыдущего слова.

  {
    register CBNL lp = *p;                      // Предыдущее слово.
    register size_t n = n1;                     // Число слов, кроме старшего.
    if (n && (CBNL)pass == (lp >> (BITS-1)))    // Если в старшем слове и в
    {                                           // старшем бите предыдущего
      do continue;                              // слова все 0 или все 1, то
      while (--n != 0 &&                        // удаляется старшее слово.
        (pass = lp, lp = p [-1], --p, (CBNL)pass == (lp >> (BITS-1))));
    }
    else { p [1] = pass; }                      // Запись старшего слова.

    return (n + 1);                             // Число слов p.
  }
}
//#define cBigNumberSub(p1,p2,p) (size_t)(*(p)=_cBigNumberSub(p1,p2,p))

//      Вычитание со сменой знака.

size_t  _cBigNumberSubS (                       // Вычитание p = p2 - p1.
                const   CBPTR(CBNL) p1,         // Вычитатель.
                const   CBPTR(CBNL) p2,         // Вычитаемое (не длиннее p1).
                        EXPTR(CBNL) p           // Буфер размера *p1 + 2.
        )                                       // p1, p2, p могут совпадать.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1++));       // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2++));       // Число слов.
  p++;
  assert (n1 >= n2);
  if (n1 == 0) return 0;                        // Return if 0 words.

  unsigned CBNL pass = ~(unsigned CBNL)0;       // Перенос в следующее слово p.
        // перенос располагается в старшем бите pass
        // unsigned CBNL обеспечивает сдвиг pass >> без расширения знака.
        // начальное значение обеспечивает прибавление единицы.
  {
    register CBNL lp1 = ~(CBNL)0;               // Текущее слово ~p1.
    register CBNL lp2 = 0;                      // Текущее слово p2.

//      Суммирование слов ~p1, p2.

    {
      size_t n;                                 // Счетчик слов.
      if ((n = n2) != 0)
      {
        do                                      // Цикл по p1, p2.
        {
          lp1 = ~(*p1++); lp2 = *p2++;
          pass = (~(*p++ = (pass >> (BITS-1)) + lp1 + lp2) & (lp1 ^ lp2))
                                                           | (lp1 & lp2);
        }
        while (--n != 0);                       // Конец цикла по p1, p2.
      }
    }

//      Перенос или заем по остатку p1, если p1 длиннее p2.

    {
      size_t n;                                 // Счетчик слов.
      if ((n = n1 - n2) != 0)
      {
        register const CBNL *pp = p1;           // Оптимизация.
        if ((lp2 & CBNL_MIN) == 0)              // p2 отрицательно.
        {
          do                                    // Цикл по p1.
          {
            lp1 = ~(*pp++);
            pass = ~(*p++ = (pass >> (BITS-1)) + lp1) & lp1;
          }
          while (--n != 0);                     // Конец цикла по p1.
        }
        else                                    // p2 неотрицательно.
        {
          do                                    // Цикл по p1.
          {
            lp1 = ~(*pp++);
            pass = ~(*p++ = (pass >> (BITS-1)) + lp1 - 1) | lp1;
          }
          while (--n != 0);                     // Конец цикла по p1.
        }
      }
    }
    --p;                                        // Подготовка указателя.

//      Суммирование расширений знаковых разрядов ~p1, p2.
//      Полученное таким образом старшее слово p состоит только из 0 или 1.
//      Старшее слово p запоминается в pass.

    pass = (pass >> (BITS-1)) + ((lp1) >> (BITS-1)) + ((lp2) >> (BITS-1));
  }

//      Нормализация - удаление лишних старших слов p, состоящих из 0 и 1
//      и совпадающих с расширением знакового разряда предыдущего слова.

  {
    register CBNL lp = *p;                      // Предыдущее слово.
    register size_t n = n1;                     // Число слов, кроме старшего.
    if (n && (CBNL)pass == (lp >> (BITS-1)))    // Если в старшем слове и в
    {                                           // старшем бите предыдущего
      do continue;                              // слова все 0 или все 1, то
      while (--n != 0 &&                        // удаляется старшее слово.
        (pass = lp, lp = p [-1], --p, (CBNL)pass == (lp >> (BITS-1))));
    }
    else { p [1] = pass; }                      // Запись старшего слова.

    return (n + 1);                             // Число слов p.
  }
}
//#define cBigNumberSubS(p1,p2,p) (size_t)(*(p)=_cBigNumberSubS(p1,p2,p))

//================================================
//      Специализированные функции накопления.
//================================================


//      Число младших 0-слов + 1 (нереентерабельно, исключается).

#ifndef _CBIGNUM_MT
static  size_t  _cBigNumberSkip = 1;            // Число 0-слов + 1.
#else //_CBIGNUM_MT
#define _cBigNumberSkip 1
#endif//_CBIGNUM_MT

//      Функция подсчета младших 0-слов.

size_t _CBNL_C  cBigNumberSkipLow0 (            // Подсчет 0-слов.
                const   CBPTR(CBNL) p1          // Буфер с числом.
)                                               // Выдает число 0-слов + 1.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  size_t n = 1;                                 // Число 0-слов + 1.

  if (n1 != 0)
  do
  {
    if (p1 [n] != 0) break;                     // Нашли ненулевое слово.
    n++;
  }
  while (--n1 != 0);

#ifndef _CBIGNUM_MT
  _cBigNumberSkip = n;                          // Число 0-слов + 1.
#endif//_CBIGNUM_MT

  return (n);                                   // Число 0-слов + 1.
}

//      Функция подсчета младших нулевых слов и копирования с их пропуском.
//
//      Функция не требует нормализации операнда, но возвращает
//      нормализованный результат, если операнд не 0.
//
//      Если операнд 0, нормализованный или не нормализованный, то функция
//      создает НЕ нормализованный 0 из 0 слов и возвращает 0.

size_t _CBNL_C  cBigNumberCopySkipLow0 (        // Сдвиг p = p1 >> exwords(p1).
                const   CBPTR(CBNL) p1,         // Число для сдвига.
                        EXPTR(CBNL) p           // Буфер размера *p1 + 1.
        )                                       // p1, p могут совпадать.
                                                // Выдает число 0-слов.
{
#ifndef _CBIGNUM_MT
  _cBigNumberSkip = 1;                          // Не пропускать 0-слова.
#endif//_CBIGNUM_MT

  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.

//      Нормализация.

  if (n1)                                       // Если в старшем слове и в
  {                                             // старшем бите предыдущего
    CBNL pass, lp = p1 [n1];                    // слова все 0 или все 1, то
    do continue;                                // удаляется старшее слово.
    while (--n1 != 0 &&
        (pass = lp, lp = p1 [n1], pass == (lp >> (BITS-1))));
    ++n1; ++p1;

//      Пропускаем младшие 0-слова и копируем.

    size_t k1 = 0;                              // Число младших 0-слов.
    do                                          // Пропуск 0-слов.
    {
      if (p1 [k1] != 0)                         // Найдено ненулевое слово.
      {
        p1 += k1;                               // Сдвиг.
        *p++ = (CBNL)n1;                        // Число слов.
        do                                      // Цикл копирования слов.
          { *p++ = *p1++; }                     // Копирование слова.
        while (--n1 != 0);                      // Конец цикла копирования.
        return (k1);                            // Число младших 0-слов.
      }
      k1++;                                     // Подсчет младших 0-слов
    }
    while (--n1 != 0);
  }

//      Выдаем НЕ нормализованный 0 из 0 слов, если все слова нулевые.

  *p = 0;                                       // НЕ нормализованный 0
  return (0);                                   // из 0 слов.
}

#ifndef _CBIGNUM_ASM                            // Если не в Cbignumf.cpp.

//      Специализированное сложение со сдвигом второго числа
//      влево на указанное число слов. Применяется при умножении.
//
//      Для целей оптимизации предполагается, что:
//      - Размер первого числа не менее, чем размер второго числа
//        после сдвига и не менее, чем размер результата.
//      - Размер второго числа до сдвига больше 0.
//      Перед сложением надо вызывать функцию cBigNumberSkipLow0()
//      для подсчета числа младших 0-слов во втором слагаемом.
//
//      Функция не требует нормализации операндов, не проводит
//      нормализацию результата и не меняет размер первого числа.

void   _CBNL_C  cBigNumberMAddM (               // Сложение p1 += p2<<k2*BITS.
                        EXPTR(CBNL) p1,         // Слагаемое, потом результат.
                const   CBPTR(CBNL) p2,         // Слагаемое размера <=*p1-k2.
                        size_t      k2          // Сдвиг слагаемого влево.
        )                                       // p1, p2 могут совпадать.
{
  const CBPTR(CBNL) pp = p1 + (size_t)(*p1);    // Последнее слово p1.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов p2.
#ifndef _CBIGNUM_MT
  assert (_cBigNumberSkip > 0);                 // Проверка параметра.
#endif//_CBIGNUM_MT
  assert ((size_t)(*p1) >= n2 + k2);            // Проверка размера.
  assert (n2 >= _cBigNumberSkip);               // Проверка размера.
  p1 += k2;                                     // Масштабирование p2.

  register unsigned CBNL pass = 0;              // Перенос: 0 или 1.
        // unsigned CBNL обеспечивает сдвиг pass >> без расширения знака.
  {
    const CBPTR(CBNL) pp = p1 + n2;             // Последнее слово p2.
    p1 += _cBigNumberSkip;                      // Коррекция начала p1.
    p2 += _cBigNumberSkip;                      // Коррекция начала p2.
    register CBNL lp1;                          // Текущее слово p1.
    register CBNL lp2;                          // Текущее слово p2.

//      Суммирование слов p1, p2.
//      Операторы цикла вычисляют логическое выражение:
//      pass = ((~(*p1 = (pass >> (BITS-1)) + lp1 + lp2) & (lp1 ^ lp2))
//                                                       | (lp1 & lp2))
//      Логическое выражение расписано в виде цепочки присваиваний:
//      pass += (lp1 + lp2)     // *p1 = pass
//      lp1  = ~(lp1 ^ lp2)     // Присваивание lp1 высвобождает регистр.
//      pass = ~(pass | lp1)    // Используется правило де Моргана
//      pass |= (lp1 & lp2)     // и тождество a & b = ~(a^b) & b.
//      Присваивания разбавлены проверками условия цикла и приращениями
//      указателей для оптимизации загрузки конвейеров Pentium.

    for (;;)                                    // Цикл по p1, p2.
    {
      lp1 = *p1;        lp2 = *p2;              // Текущие слова p1, p2.
      pass += lp1;      lp1 ^= lp2;
      pass += lp2;      lp1 = ~lp1;
      *p1 = pass;       pass |= lp1;
      lp1 &= lp2;       pass = ~pass;
      ++p2;             pass |= lp1;
      if (p1 >= pp)     break;
      ++p1;             pass >>= (BITS-1);
    }
    if ((CBNL)(lp2 ^= pass) >= 0) return;       // Переноса или займа нет.
  }

//      Перенос или заем по остатку p1, если p1 длиннее p2.
//      Предусловие: p1 указывает на последнее полученное слово,
//                   pass содержит перенос в старшем бите.

  {
    register CBNL lp1;                          // Текущее слово p1.
    if ((CBNL)pass < 0)                         // p2 неотрицательно.
    {
      do                                        // Цикл по p1.
      {
        if (p1 >= pp) break;
        lp1 = *++p1;
      }
      while ((~(*p1 = lp1 + 1) & lp1) < 0);
    }
    else                                        // p2 отрицательно.
    {
      do                                        // Цикл по p1.
      {
        if (p1 >= pp) break;
        lp1 = *++p1;
      }
      while ((~(*p1 = lp1 - 1) | lp1) >= 0);
    }
  }
}

//      Специализированное вычитание со сдвигом второго числа
//      влево на указанное число слов. Применяется при умножении.
//
//      Для целей оптимизации предполагается, что:
//      - Размер первого числа не менее, чем размер второго числа
//        после сдвига и не менее, чем размер результата.
//      - Размер второго числа до сдвига больше 0.
//      Перед вычитанием надо вызывать функцию cBigNumberSkipLow0()
//      для подсчета числа младших 0-слов во втором слагаемом.
//
//      Функция не требует нормализации операндов, не проводит
//      нормализацию результата и не меняет размер первого числа.

void   _CBNL_C  cBigNumberMSubM (               // Вычитание p1 -= p2<<k2*BITS.
                        EXPTR(CBNL) p1,         // Вычитаемое, потом результат.
                const   CBPTR(CBNL) p2,         // Вычитатель размера <=*p1-k2.
                        size_t      k2          // Сдвиг вычитаемого влево.
        )                                       // p1, p2 могут совпадать.
{
  const CBPTR(CBNL) pp = p1 + (size_t)(*p1);    // Последнее слово p1.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов p2.
#ifndef _CBIGNUM_MT
  assert (_cBigNumberSkip > 0);                 // Проверка параметра.
#endif//_CBIGNUM_MT
  assert ((size_t)(*p1) >= n2 + k2);            // Проверка размера.
  assert (n2 >= _cBigNumberSkip);               // Проверка размера.
  p1 += k2;                                     // Масштабирование p2.

  register CBNL pass = 0;                       // Перенос: 0 или 1.
        // CBNL обеспечивает сдвиг pass >> с расширением знака.
  {
    const CBPTR(CBNL) pp = p1 + n2;             // Последнее слово p2.
    p1 += _cBigNumberSkip;                      // Коррекция начала p1.
    p2 += _cBigNumberSkip;                      // Коррекция начала p2.
    register CBNL lp1;                          // Текущее слово p1.
    register CBNL lp2;                          // Текущее слово p2.

//      Вычитание слов p1, p2.
//      Операторы цикла вычисляют логическое выражение:
//      pass = (((*p1 = (pass >> (BITS-1)) + lp1 - lp2) | (lp1 ^ lp2))
//                                                     & (~lp1 | lp2))
//      Логическое выражение расписано в виде цепочки присваиваний:
//      pass += (lp1 - lp2)     // *p1 = pass
//      pass |= (lp1 ^= lp2)    // Присваивание lp1 высвобождает регистр.
//      pass = ~pass;           // Используется правило Де Моргана
//      pass |= (lp1 & ~lp2)    // и тождество a & ~b = (a^b) & ~b.
//      pass = ~pass;
//      Присваивания разбавлены проверками условия цикла и приращениями
//      указателей для оптимизации загрузки конвейеров Pentium.

    for (;;)                                    // Цикл по p1, p2.
    {
      lp1 = *p1;        lp2 = *p2;              // Текущие слова p1, p2.
      pass += lp1;      lp1 ^= lp2;
      pass -= lp2;      lp2 = ~lp2;
      *p1 = pass;       pass |= lp1;
      lp1 &= lp2;       pass = ~pass;
      ++p2;             pass |= lp1;
      if (p1 >= pp)     break;
      ++p1;             pass >>= (BITS-1);
                        pass = ~pass;
    }
    if ((CBNL)(lp2 ^= pass) >= 0) return;       // Переноса или займа нет.
  }

//      Перенос или заем по остатку p1, если p1 длиннее p2.
//      Предусловие: p1 указывает на последнее полученное слово,
//                   pass содержит перенос в старшем бите.

  {
    register CBNL lp1;                          // Текущее слово p1.
    if ((CBNL)pass < 0)                         // p2 отрицательно.
    {
      do                                        // Цикл по p1.
      {
        if (p1 >= pp) break;
        lp1 = *++p1;
      }
      while ((~(*p1 = lp1 + 1) & lp1) < 0);
    }
    else                                        // p2 неотрицательно.
    {
      do                                        // Цикл по p1.
      {
        if (p1 >= pp) break;
        lp1 = *++p1;
      }
      while ((~(*p1 = lp1 - 1) | lp1) >= 0);
    }
  }
}

//      Специализированное вычитание со сдвигом второго числа
//      на указанное число слов. Применяется при делении.
//
//      Для целей оптимизации предполагается, что:
//      - Числа имеют одинаковый знак.
//      - Размер первого числа не менее, чем размер второго числа
//        после сдвига.
//      - Размер второго числа до сдвига больше 0.
//      - После вычитания число значащих бит в числе уменьшается.
//      - После вычитания знак числа не меняется,
//        кроме обнуления отрицательных чисел.
//      Перед вычитанием надо вызывать функцию cBigNumberSkipLow0()
//      для подсчета числа младших 0-слов в вычитаемом.
//
//      Функция не требует нормализации операндов и всегда
//      выдает нормализованное число.

size_t _CBNL_C _cBigNumberMSubD (               // Вычитание p1 -= p2<<k2*BITS.
                        EXPTR(CBNL) p1,         // Вычитаемое, потом результат.
                const   CBPTR(CBNL) p2,         // Вычитатель размера <=*p1-k2.
                        size_t      k2          // Сдвиг вычитателя влево.
        )                                       // p1, p2 могут совпадать.
{
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов p2.
#ifndef _CBIGNUM_MT
  assert (_cBigNumberSkip > 0);                 // Проверка параметра.
#endif//_CBIGNUM_MT
  assert ((p1 [(size_t)(*p1)] ^ p2 [n2]) >= 0); // Проверка знаков.
  assert ((size_t)(*p1) >= n2 + k2);            // Проверка размера.
  assert (n2 >= _cBigNumberSkip);               // Проверка размера.
  p1 += k2;                                     // Масштабирование p2.

  register CBNL pass = 0;                       // Заем: 0 или -1.
        // CBNL обеспечивает сдвиг pass >> с расширением знака.
  {
    const CBPTR(CBNL) pp = p1 + n2;             // Последнее слово p2.
    p1 += _cBigNumberSkip;                      // Коррекция начала p1.
    p2 += _cBigNumberSkip;                      // Коррекция начала p2.
    register CBNL lp1;                          // Текущее слово p1.
    register CBNL lp2;                          // Текущее слово p2.

//      Вычитание слов p1, p2.
//      Операторы цикла вычисляют логическое выражение:
//      pass = (((*p1 = (pass >> (BITS-1)) + lp1 - lp2) | (lp1 ^ lp2))
//                                                     & (~lp1 | lp2))
//      Логическое выражение расписано в виде цепочки присваиваний:
//      pass += (lp1 - lp2)     // *p1 = pass
//      pass |= (lp1 ^= lp2)    // Присваивание lp1 высвобождает регистр.
//      pass &=~(lp1 & ~lp2)    // Используется правило Де Моргана
//                              // и тождество a & ~b = (a^b) & ~b.
//      Присваивания разбавлены проверками условия цикла и приращениями
//      указателей для оптимизации загрузки конвейеров Pentium.

    for (;;)                                    // Цикл по p1, p2.
    {
      lp1 = *p1;        lp2 = *p2;              // Текущие слова p1, p2.
      pass += lp1;      lp1 ^= lp2;
      pass -= lp2;      lp2 = ~lp2;
      *p1 = pass;       lp2 &= lp1;
      if (p1 >= pp)     break;
      lp2 = ~lp2;       pass |= lp1;
      ++p1;             pass &= lp2;
      ++p2;             pass >>= (BITS-1);
    }
  }

//      Нормализация - удаление лишних старших слов p, состоящих из 0 и 1
//      и совпадающих с расширением знакового разряда предыдущего слова.
//      Предусловие: p1 указывает на последнее полученное слово,
//                   копия которого находится в pass.

  {
    register size_t n1 = n2 + k2;

//      В цикле выполняются операции:
//      do continue;
//      while (--n1 != 0 &&
//              lp1 == (lp1 = pass, pass = p1 [-1], --p1, pass >> (BITS-1)));

    for (;;)
    {
      register CBNL lp1;                        // Старшее слово.
      register CBNL lp2;                        // Предыдущее слово.
      if (--n1 == 0)    break;                  // Осталось одно слово.
      lp2 = p1 [-1];    --p1;
      lp1 = pass;       pass = lp2;
      lp2 >>= (BITS-1);
      if (lp1 != lp2)   break;
    }
    return (n1 + 1);                            // Число слов p.
  }
}
//#define cBigNumberMSubD(p1,p2,k2) (size_t)(*(p1)=_cBigNumberMSubD(p1,p2,k2))

//      Специализированный сдвиг влево на 1 бит (для у
//      Применяется при умножении.
//
//      Предполагается, что число не равно 0.
//      Перед сдвигом надо вызывать функцию cBigNumberSkipLow0()
//      для подсчета числа младших 0-слов в буфере.
//
//      Сдвиг влево выполняется последовательно с переносом
//      старшего разряда в последующее слово и формированием
//      еще одного слова, полученного расширением знакового
//      разряда старшего слова. Если два последних разряда
//      старшего слова не совпадают, то размер числа увеличивается
//      на 1, т.е. добавленное слово становится знаковым.
//
//      Функция не требует нормализации операндов и не проводит
//      нормализацию результата, но выдает нормализованный
//      результат в случае, если операнд нормализован.

size_t _CBNL_C _cBigNumberMMul2M (              // Сдвиг p1 <<= 1.
                        EXPTR(CBNL) p1          // Буфер размера *p1 + 2.
        )
{
  size_t n1 = (size_t)(*p1);                    // Число слов.
#ifndef _CBIGNUM_MT
  assert (_cBigNumberSkip > 0);                 // Проверка параметра.
#endif//_CBIGNUM_MT
  assert (n1 >= _cBigNumberSkip);               // Проверка размера.

  const CBPTR(CBNL) pp = p1 + n1;               // Последнее слово p1.
  p1 += _cBigNumberSkip;                        // Первое ненулевое слово p1.
  CBNL num = 0;                                 // Слово до сдвига.
  do                                            // Цикл сдвига слов.
  {
    CBNL pass = (unsigned CBNL)num >> (BITS-1); // Разряд из предыдущего слова.
    num = *p1;                                  // Текущее слово до сдвига.
    *p1++ = (num << 1) | pass;                  // Текущее слово после сдвига.
  }
  while (p1 <= pp);                             // Цикл сдвига слов.

  num >>= (BITS-2);                             // Расширение знака
  n1 += (num != (*p1 = num >> 1));              // при переполнении.

  return (n1);                                  // Число слов.
}
//#define cBigNumberMMul2M(p1)   (size_t)(*(p1)=_cBigNumberMMul2M(p1))

//      Специализированный сдвиг вправо на 1 бит.
//      Применяется при делении и вычислении квадратного корня.
//
//      Предполагается, что:
//      - Число не равно 0.
//      - Младший бит младшего ненулевого слова нулевой.
//      Перед сдвигом надо вызывать функцию cBigNumberSkipLow0()
//      для подсчета числа младших 0-слов в буфере.
//
//      Сдвиг вправо выполняется последовательно с переносом
//      старшего разряда в предыдущее слово.
//      Сдвиг старшего слова знаковый, остальных - беззнаковый.
//      Если до сдвига все разряды старшего слова совпадают,
//      то старшее слово результата удаляется.
//
//      Функция не требует нормализации операндов и не проводит
//      нормализацию результата, но выдает нормализованный
//      результат в случае, если операнд нормализован.

size_t _CBNL_C _cBigNumberMDiv2D (              // Сдвиг p1 >>= 1.
                        EXPTR(CBNL) p1          // Буфер размера *p1 + 1.
        )
{
  size_t n1 = (size_t)(*p1);                    // Число слов.
#ifndef _CBIGNUM_MT
  assert (_cBigNumberSkip > 0);                 // Проверка параметра.
#endif//_CBIGNUM_MT
  assert (n1 >= _cBigNumberSkip);               // Проверка размера.
  assert ((p1 [_cBigNumberSkip] & (CBNL)1)==0); // Проверка младшего бита.

  const CBPTR(CBNL) pp = p1 + _cBigNumberSkip;  // Первое ненулевое слово p1.
  p1 += n1;                                     // Старшее слово.
  CBNL num = *p1;                               // Старшее слово до сдвига.
  n1 -= (n1 > 1) & (num == (*p1-- = num >> 1)); // Сдвиг старшего слова и его
                                                // удаление, если 0 или ~0.
  while (p1 >= pp)                              // Цикл сдвига слов.
  {
    CBNL pass = num << (BITS-1);                // Разряд из следующего слова.
    num = *p1;                                  // Текущее слово до сдвига.
    *p1-- = ((unsigned CBNL)num >> 1) | pass;   // Текущее слово после сдвига.
  }                                             // Конец цикла сдвига слов.

  return (n1);                                  // Число слов.
}
//#define cBigNumberMDiv2D(p1)   (size_t)(*(p1)=_cBigNumberMDiv2D(p1))

#endif//_CBIGNUM_ASM

//      Специализированный сдвиг числа на одно слово вправо для умножения.
//      Исходное число должно содержать, как минимум, два слова.

void    cBigNumberMShrM (                       // Сдвиг p1 >>= BITS.
                        EXPTR(CBNL) p1          // Буфер размера *p1 + 1.
        )
{
  size_t n1 = (size_t)(*p1);                    // Число слов.
  assert (n1 > 1);                              // Проверка.
  *p1 = (CBNL)--n1;
  do                                            // Цикл копирования слов.
    { p1 [1] = p1 [2]; p1++; }                  // Копирование слова.
  while ((CBNL)--n1 > 0);                       // Конец цикла копирования.
}

//      Сдвиг числа на одно слово влево для деления.
//      Исходное число должно содержать, как минимум, одно слово.

void    cBigNumberMShlD (                       // Сдвиг p1 <<= BITS.
                        EXPTR(CBNL) p1          // Буфер размера *p1 + 2.
        )
{
  size_t n1 = (size_t)(*p1);                    // Число слов.
  assert (n1 > 0);                              // Проверка.
  *p1 = (CBNL)(n1 + 1);
  do                                            // Цикл копирования слов.
    { p1 [n1 + 1] = p1 [n1]; }                  // Копирование слова.
  while ((CBNL)--n1 > 0);                       // Конец цикла копирования.
  p1 [1] = 0;
}

//      Функции быстрого накопления со сдвигом, оптимальные для
//      больших чисел, в особенности для большого накопителя.
//
//      Функции не требуют нормализации операндов и всегда выдают
//      нормализованный результат.

void    cBigNumberMAddShl (                     // Сложение p1 += p2<<k2*BITS.
                        EXPTR(CBNL) p1,         // Слагаемое, потом результат
                                                // в буфере размера
                                                // max (*p1, *p2 + k2) + 2.
                const   CBPTR(CBNL) p2,         // Слагаемое.
                        size_t      k2          // Сдвиг слагаемого влево.
        )                                       // p1, p2 могут перекрываться.
{
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.

  cBigNumberFitTo (p1, n2 + k2 + 1);            // Денормализация.
#ifndef _CBIGNUM_MT
  _cBigNumberSkip = 1;                          // Не пропускать 0-слова.
#endif//_CBIGNUM_MT
  if (n2 > 0) cBigNumberMAddM (p1, p2, k2);     // Быстрое сложение.

  cBigNumberFit (p1);                           // Нормализация.
}

void    cBigNumberMSubShl (                     // Вычитание p1 -= p2<<k2*BITS.
                        EXPTR(CBNL) p1,         // Вычитаемое, потом результат
                                                // в буфере размера
                                                // max (*p1, *p2 + k2) + 2.
                const   CBPTR(CBNL) p2,         // Вычитатель.
                        size_t      k2          // Сдвиг вычитаемого влево.
        )                                       // p1, p2 могут перекрываться.
{
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.

  cBigNumberFitTo (p1, n2 + k2 + 1);            // Денормализация.
#ifndef _CBIGNUM_MT
  _cBigNumberSkip = 1;                          // Не пропускать 0-слова.
#endif//_CBIGNUM_MT
  if (n2 > 0) cBigNumberMSubM (p1, p2, k2);     // Быстрое вычитание.

  cBigNumberFit (p1);                           // Нормализация.
}

//================================================
//      Функции умножения.
//================================================

//      Здесь дана битовая реализация на стандартном С++.
//      Более быстрая реализация с применением аппаратного
//      умножения предусмотрена в Cbignumf.cpp.

#ifndef _CBIGNUM_HARDWARE_MUL                   // Если не в Cbignumf.cpp.

//      Специализированные функции умножения со сдвигом и накоплением.
//      Множимое иcпользуется, как рабочий буфер и будет портиться.
//
//      Множитель рассматривается, как БЕЗЗНАКОВОЕ число,
//      т.е. знаковые биты обрабатываются, как старшие биты.
//
//      Функции не требуют нормализации операндов и всегда выдают
//      нормализованный результат.

void    cBigNumberMAddMulShl (                  // Умножение со сложением
                                                // p += p1 * p2 << k*BITS.
                        EXPTR(CBNL) p1,         // Множимое в перетираемом
                                                // буфере размера *p1 + 3.
                const   CBPTR(CBNL) p2,         // Беззнаковый множитель.
                        size_t      k,          // Сдвиг произведения влево.
                        EXPTR(CBNL) p           // Слагаемое в буфере размера
                                                // max (*p, *p1 + *p2 + k) + 2.
        )                                       // p1,p2,p не могут совпадать.
{
  assert (p1 != p);                             // Проверка несовпадения.
  assert (p2 != p);                             // Проверка несовпадения.
  assert (p2 != p1);                            // Проверка несовпадения.
  size_t n1 = (size_t)(*p1);                    // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.

//      Алгоритм умножения, не применяющий таблицу сдвигов.

  if (n1 >= cBigNumberSkipLow0 (p1) && n2 != 0) // Операнды непустые?
  {
    cBigNumberFitTo (p, n1 + n2 + k + 1);       // Денормализация.
    --n2;
    size_t k2 = 0;
    for (; k2 != n2; k2++)                      // Цикл по словам p2.
    {
      CBNL num = p2 [k2 + 1];                   // Очередное слово p2.
      if (num == 0) continue;                   // Оптимизация.
      CBNL mask = 1;                            // Маска для битов num.
      for (;; cBigNumberMMul2M (p1))            // Цикл по битам слова p2.
      {
        if (num & mask) cBigNumberMAddM (p, p1, k + k2);
        if ((mask <<= 1) == 0) break;           // Биты закончились.
      }                                         // Конец цикла по битам p2.
      cBigNumberMMul2M (p1);                    // Сдвиг множимого на бит.
      cBigNumberMShrM (p1);                     // Восстановление множимого.
    }                                           // Конец цикла по словам p2.
    {
      CBNL num = p2 [k2 + 1];                   // Последнее слово p2.
      CBNL mask = (num != 0);                   // Маска для битов num.
      if (num > 0)                              // Старший бит num может
      do                                        // быть не 0 при p2 < 0.
        mask <<= 1;                             // Сдвигаем mask и num, пока
      while ((num <<= 1) > 0);                  // старший бит num равен 0.
      for (;; cBigNumberMMul2M (p1))            // Цикл по битам слова p2.
      {
        if (num & mask) cBigNumberMAddM (p, p1, k + k2);
        if ((mask <<= 1) == 0) break;           // Биты закончились.
      }                                         // Конец цикла по битам p2.
    }
  }

  cBigNumberFit (p);                            // Нормализация.
#ifndef _CBIGNUM_MT
  _cBigNumberSkip = 1;                          // Не пропускать 0-слова.
#endif//_CBIGNUM_MT
}

void    cBigNumberMSubMulShl (                  // Умножение с вычитанием
                                                // p -= p1 * p2 << k*BITS.
                        EXPTR(CBNL) p1,         // Множимое в перетираемом
                                                // буфере размера *p1 + 3.
                const   CBPTR(CBNL) p2,         // Беззнаковый множитель.
                        size_t      k,          // Сдвиг произведения влево.
                        EXPTR(CBNL) p           // Вычитаемое в буфере размера
                                                // max (*p, *p1 + *p2 + k) + 2.
        )                                       // p1,p2,p не могут совпадать.
{
  assert (p1 != p);                             // Проверка несовпадения.
  assert (p2 != p);                             // Проверка несовпадения.
  assert (p2 != p1);                            // Проверка несовпадения.
  size_t n1 = (size_t)(*p1);                    // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.

//      Алгоритм умножения, не применяющий таблицу сдвигов.

  if (n1 >= cBigNumberSkipLow0 (p1) && n2 != 0) // Операнды непустые?
  {
    cBigNumberFitTo (p, n1 + n2 + k + 1);       // Денормализация.
    --n2;
    size_t k2 = 0;
    for (; k2 != n2; k2++)                      // Цикл по словам p2.
    {
      CBNL num = p2 [k2 + 1];                   // Очередное слово p2.
      if (num == 0) continue;                   // Оптимизация.
      CBNL mask = 1;                            // Маска для битов num.
      for (;; cBigNumberMMul2M (p1))            // Цикл по битам слова p2.
      {
        if (num & mask) cBigNumberMSubM (p, p1, k + k2);
        if ((mask <<= 1) == 0) break;           // Биты закончились.
      }                                         // Конец цикла по битам p2.
      cBigNumberMMul2M (p1);                    // Сдвиг множимого на бит.
      cBigNumberMShrM (p1);                     // Восстановление множимого.
    }                                           // Конец цикла по словам p2.
    {
      CBNL num = p2 [k2 + 1];                   // Последнее слово p2.
      CBNL mask = (num != 0);                   // Маска для битов num.
      if (num > 0)                              // Старший бит num может
      do                                        // быть не 0 при p2 < 0.
        mask <<= 1;                             // Сдвигаем mask и num, пока
      while ((num <<= 1) > 0);                  // старший бит num равен 0.
      for (;; cBigNumberMMul2M (p1))            // Цикл по битам слова p2.
      {
        if (num & mask) cBigNumberMSubM (p, p1, k + k2);
        if ((mask <<= 1) == 0) break;           // Биты закончились.
      }                                         // Конец цикла по битам p2.
    }
  }

  cBigNumberFit (p);                            // Нормализация.
#ifndef _CBIGNUM_MT
  _cBigNumberSkip = 1;                          // Не пропускать 0-слова.
#endif//_CBIGNUM_MT
}

#endif//_CBIGNUM_HARDWARE_MUL

//      Специализированные функции умножения со сдвигом и накоплением.
//      В буфере множимого должна находится таблица сдвигов, полученная
//      функцией cBigNumberTab(). Метод эффективен, если размер
//      хотя бы одного операнда не превосходит _CBNL_KARATSUBA_MIN * 2.
//      Для лучшей производительности операнд большего размера следует
//      поставить первым, если только его размер не больше _CBNL_TAB_OPT.
//
//      Множитель рассматривается, как БЕЗЗНАКОВОЕ число,
//      т.е. знаковые биты обрабатываются, как старшие биты.
//
//      Функции не требуют нормализации операндов и всегда выдают
//      нормализованный результат.

void    cBigNumberMAddMulShlTab (               // Умножение со сложением
                                                // p += p1 *p2 << k*BITS.
                const   CBPTR(CBNL) p1,         // Множимое и таблица сдвигов.
                const   CBPTR(CBNL) p2,         // Беззнаковый множитель.
                        size_t      k,          // Сдвиг произведения влево.
                        EXPTR(CBNL) p           // Слагаемое в буфере размера
                                                // max (*p, *p1 + *p2 + k) + 2.
        )                                       // p1, p2 могут совпадать.
{
  assert (p1 != p);                             // Проверка несовпадения.
  assert (p2 != p);                             // Проверка несовпадения.
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.

//      Алгоритм умножения с таблицей сдвигов.

  if (n1 >= cBigNumberSkipLow0 (p1) && n2 != 0) // Операнды непустые?
  {
    cBigNumberFitTo (p, n1 + n2 + k + 1);       // Денормализация.
    n1 += 2;                                    // Шаг таблицы сдвигов.
#ifndef _CBIGNUM_TERNARY_MUL
    for (size_t k2 = 0; k2 != n2; k2++)         // Цикл по словам p2.
    {
      CBNL num = p2 [k2 + 1];                   // Очередное слово p2.
      CBNL mask = 1;                            // Маска для битов num.
      const CBPTR(CBNL) pp1 = p1;               // Текущий сдвиг.
      for (;; pp1 += n1)                        // Цикл по битам слова p2.
      {
        if (num & mask) cBigNumberMAddM (p, pp1, k + k2);
        if ((mask <<= 1) == 0) break;           // Биты закончились.
      }                                         // Конец цикла по битам p2.
    }                                           // Конец цикла по словам p2.
#else //_CBIGNUM_TERNARY_MUL
    CBNL num2 = p2 [n2], num1 = num2;           // Старший бит старшего слова.
    num2 <<= 1;                                 // Следующий бит.
    CBNL mode = 0;                              // 0=сложение, -1=вычитание.
    if ((num1 & num2) < 0)                      // Старшие биты все 1.
    {
      cBigNumberMAddM (p, p1, k + n2);          // Сложение со сдвигом n2.
      num1 = ~num1; num2 = ~num2;
      mode = ~(CBNL)0;                          // Режим вычитания.
    }
    p1 += n1 * BITS; p1 -= n1;                  // Начальный сдвиг.
    for (size_t k2 = n2; k2-- != 0;)            // Цикл по словам p2.
    {
      const CBPTR(CBNL) pp1 = p1;               // Текущий сдвиг.
      for (size_t kb = BITS;; pp1 -= n1)        // Цикл по битам слова p2.
      {
        CBNL num = num1;                        // Текущий бит.
        num1 = num2;                            // 1-й следующий бит.
        if (kb != 2) num2 <<= 1;                // 2-й следующий бит.
        else num2 = (k2? p2 [k2]: 0L) ^ mode;   // Слово закончилось.
        if ((num | (num1 & num2) ) < 0)         // Критерий накопления.
        {
           if (mode == 0) cBigNumberMAddM (p, pp1, k + k2);
           else           cBigNumberMSubM (p, pp1, k + k2);
           if (num >= 0) { num1 = ~num1; num2 = ~num2; mode = ~mode; }
        }                                       // Смена режима.
        if (--kb == 0) break;                   // Биты закончились.
      }                                         // Конец цикла по битам p2.
    }                                           // Конец цикла по словам p2.
#endif//_CBIGNUM_TERNARY_MUL
  }

  cBigNumberFit (p);                            // Нормализация.
#ifndef _CBIGNUM_MT
  _cBigNumberSkip = 1;                          // Не пропускать 0-слова.
#endif//_CBIGNUM_MT
}

void    cBigNumberMSubMulShlTab (               // Умножение с вычитанием
                                                // p -= p1 *p2 << k*BITS.
                const   CBPTR(CBNL) p1,         // Множимое и таблица сдвигов.
                const   CBPTR(CBNL) p2,         // Беззнаковый множитель.
                        size_t      k,          // Сдвиг произведения влево.
                        EXPTR(CBNL) p           // Вычитаемое в буфере размера
                                                // max (*p, *p1 + *p2 + k) + 2.
        )                                       // p1, p2 могут совпадать.
{
  assert (p1 != p);                             // Проверка несовпадения.
  assert (p2 != p);                             // Проверка несовпадения.
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.

//      Алгоритм умножения с таблицей сдвигов.

  if (n1 >= cBigNumberSkipLow0 (p1) && n2 != 0) // Операнды непустые?
  {
    cBigNumberFitTo (p, n1 + n2 + k + 1);       // Денормализация.
    n1 += 2;                                    // Шаг таблицы сдвигов.
#ifndef _CBIGNUM_TERNARY_MUL
    for (size_t k2 = 0; k2 != n2; k2++)         // Цикл по словам p2.
    {
      CBNL num = p2 [k2 + 1];                   // Очередное слово p2.
      CBNL mask = 1;                            // Маска для битов num.
      const CBPTR(CBNL) pp1 = p1;               // Текущий сдвиг.
      for (;; pp1 += n1)                        // Цикл по битам слова p2.
      {
        if (num & mask) cBigNumberMSubM (p, pp1, k + k2);
        if ((mask <<= 1) == 0) break;           // Биты закончились.
      }                                         // Конец цикла по битам p2.
    }                                           // Конец цикла по словам p2.
#else //_CBIGNUM_TERNARY_MUL
    CBNL num2 = p2 [n2], num1 = num2;           // Старший бит старшего слова.
    num2 <<= 1;                                 // Следующий бит.
    CBNL mode = 0;                              // 0=вычитание, -1=сложение.
    if ((num1 & num2) < 0)                      // Старшие биты все 1.
    {
      cBigNumberMSubM (p, p1, k + n2);          // Вычитание со сдвигом n2.
      num1 = ~num1; num2 = ~num2;
      mode = ~(CBNL)0;                          // Режим сложения.
    }
    p1 += n1 * BITS; p1 -= n1;                  // Начальный сдвиг.
    for (size_t k2 = n2; k2-- != 0;)            // Цикл по словам p2.
    {
      const CBPTR(CBNL) pp1 = p1;               // Текущий сдвиг.
      for (size_t kb = BITS;; pp1 -= n1)        // Цикл по битам слова p2.
      {
        CBNL num = num1;                        // Текущий бит.
        num1 = num2;                            // 1-й следующий бит.
        if (kb != 2) num2 <<= 1;                // 2-й следующий бит.
        else num2 = (k2? p2 [k2]: 0L) ^ mode;   // Слово закончилось.
        if ((num | (num1 & num2) ) < 0)         // Критерий накопления.
        {
           if (mode == 0) cBigNumberMSubM (p, pp1, k + k2);
           else           cBigNumberMAddM (p, pp1, k + k2);
           if (num >= 0) { num1 = ~num1; num2 = ~num2; mode = ~mode; }
        }                                       // Смена режима.
        if (--kb == 0) break;                   // Биты закончились.
      }                                         // Конец цикла по битам p2.
    }                                           // Конец цикла по словам p2.
#endif//_CBIGNUM_TERNARY_MUL
  }

  cBigNumberFit (p);                            // Нормализация.
#ifndef _CBIGNUM_MT
  _cBigNumberSkip = 1;                          // Не пропускать 0-слова.
#endif//_CBIGNUM_MT
}

#ifndef _CBIGNUM_HARDWARE_MUL                   // Если не в Cbignumf.cpp.

//      Специализированные функции умножения со сдвигом и накоплением.
//      Для ускорения применяется метод Карацубы или метод умножения
//      по частям, а также строятся временные таблицы сдвигов.
//      Для лучшей производительности операнд существенно большего
//      размера рекомендуется поставить первым.
//
//      Множитель рассматривается, как БЕЗЗНАКОВОЕ число,
//      т.е. знаковые биты обрабатываются, как старшие биты.
//
//      Функции не требуют нормализации операндов и всегда выдают
//      нормализованный результат.

void    cBigNumberMAddMulShlKar (               // Умножение со сложением
                                                // p += p1 *p2 << k*BITS.
                        EXPTR(CBNL) p1,         // Множимое в перетираемом
                                                // буфере размера *p1 + 3 +
                                                // *p2 < _CBNL_TAB_MIN?
                                                //  (min (*p1, _CBNL_TAB_HIGH)
                                                //   + 2) * (BITS - 1).
                        EXPTR(CBNL) p2,         // Беззнаковый множитель.
                        size_t      k,          // Сдвиг произведения влево.
                        EXPTR(CBNL) p           // Слагаемое в буфере размера
                                                // max (*p, *p1 + *p2 + k + 1)
                                                //                        + 2.
        )                                       // p1, p2 могут совпадать.
{
  assert (p1 != p);                             // Проверка несовпадения.
  assert (p2 != p);                             // Проверка несовпадения.
  size_t n1 = (size_t)(*p1);                    // Число слов.
  size_t n2 = (size_t)(*p2);                    // Число слов.

//      Проверка применимости метода Карацубы.

#ifdef  _CBIGNUM_KARATSUBA_MUL
  if (n1 > _CBNL_KARATSUBA_MIN && n2 > _CBNL_KARATSUBA_MIN)
  {

//      Умножение большого 1-го операнда по частям.
//      ПРИМЕЧАНИЕ: Алгоритм требует сохранения p2 при рекурсивном вызове.

    while (n1 > n2 * 2 - n2 / 4)                // Проверка размера.
    {
      CBNL lp = p1 [n1 -= n2];                  // Сохранение затираемого
      p1 [n1] = (CBNL) n2;                      // слова и запоминание размера.
      cBigNumberMAddMulShlKar (p1 + n1, p2, k + n1, p);
      p1 [n1] = lp;                             // Восстановление слова.
      p1 [n1 + 1] = 0; n1 += (lp < 0);          // Добавление старшего 0-слова.
      p1 [0] = (CBNL) n1;                       // Размер последней части.
    }

//      Умножение операндов близкого размера по методу Карацубы.

    size_t n = (n1 >= n2? n1: n2 - 1) / 2;      // Размер младшей части.

//      ПРИМЕЧАНИЕ: Чтобы не было переполнения p в редком специальном
//                  случае, когда p1 вдвое короче p2 или еще меньше,
//                  старшая часть p2 должна быть длиннее младшей части p2.

    cBigTemp c12; c12.checkexpand (n * 2 + 5);
    EXPTR(CBNL) p12 = EXPTRTYPE(c12);           // Буфер для умножения.

    cBigTemp c1; c1.checkexpand (n + 2);
    cBigTemp c2; c2.checkexpand (n + 4);
    cBigNumberCopyShr (p2, n, EXPTRTYPE(c2));   // Старшая часть p2 в c2.

//      Размер p1 может быть n или меньше если p1 вдвое или более короче p2.
//      ПРИМЕЧАНИЕ: Алгоритм требует сохранения c2 при рекурсивном вызове.

    if (n1 > n)
    {
      cBigNumberCopyShr (p1, n, EXPTRTYPE(c1)); // Старшая часть p1 в c1.
      CBNL lp = p1 [n];                         // Сохранение затираемого
      p1 [n] = (CBNL)(n1 - n);                  // слова и запоминание размера.
      p12 [0] = 0;                              // Очистка буфера умножения.
      cBigNumberMAddMulShlKar (p1 + n, EXPTRTYPE(c2), 0, p12);
                                                // Умножение c1 * c2.
      cBigNumberMAddShl (p, p12, k + n * 2);    // Накопление c1 * c2.
      cBigNumberMSubShl (p, p12, k + n);        // Накопление c1 * c2.
      p1 [n] = lp;                              // Восстановление слова.
      p1 [n + 1] = 0;                           // Добавление старшего 0-слова.
      p1 [0] = (CBNL)(n + (lp < 0));            // Младшая часть p1.
      cBigNumberMAddShl (EXPTRTYPE(c1), p1, 0); // Сложение c1 + p1.
    }
    else
      cBigNumberCopy (p1, EXPTRTYPE(c1));       // Копирование p1 в c1.

//      Размер p2 не может быть n или меньше.

    assert (n2 > n);
    {
      size_t nc2 = c2.length() + 1;             // Добавление старшего 0-слова.
      c2.item (0) = (CBNL) nc2;
      ((EXPTR(CBNL)) EXPTRTYPE(c2)) [nc2] = 0;

      CBNL lp = p2 [n + 1];                     // Сохранение слова.
      p2 [n + 1] = 0;                           // Добавление старшего 0-слова.
      p2 [0] = (CBNL)(n + 1);                   // Младшая часть p2.
      cBigNumberMAddShl (EXPTRTYPE(c2), p2, 0); // Сложение c2 + p2.
      p2 [n + 1] = lp;                          // Восстановление слова.

      p2 [0] = (CBNL) n;                        // Удаление старшего 0-слова.
      p12 [0] = 0;                              // Очистка буфера умножения.
      cBigNumberMAddMulShlKar (p1, p2, 0, p12); // Умножение p1 * p2.
      p2 [0] = (CBNL) n2;                       // Восстановление исходного p2.

      c2.item (0) = (CBNL)(c2.length() - (c2.hiword() == 0));
                                                // Удаление старшего 0-слова.
      cBigNumberCopy (CBPTRTYPE(c1), p1);       // Накопление (c1+p2)*(c2+p2).
      cBigNumberMAddMulShlKar (p1, EXPTRTYPE(c2), k + n, p);

      cBigNumberMSubShl (p, p12, k + n);        // Накопление p1 * p2.
      cBigNumberMAddShl (p, p12, k);            // Накопление p1 * p2.
    }

    return;
  }
#endif//_CBIGNUM_KARATSUBA_MUL

//      Умножение 1-го операнда по частям, если 2-ой операнд небольшой.
//
//      Старшая часть может быть положительной или отрицательной, но младшие
//      части всегда положительные, поэтому добавляем к ним старшее 0-слово.
//      Старшая и последующие части содержат _CBNL_TAB_OPT + 1 слов,
//      включая старшее 0-слово для всех частей кроме старшей, самая
//      младшая часть может содержать до _CBNL_TAB_HIGH слов вместе со
//      добавочным старшим 0-словом.
//
//      Алгоритм выделяет части без копирования.

#ifdef  _CBIGNUM_BLOCK_MUL
  if (n1 > _CBNL_TAB_HIGH)
  {                                             // Учет старшего слова
    --n1;                                       // старшей части.
    do                                          // Цикл по частям.
    {
      n1 -= _CBNL_TAB_OPT;                      // Размер всех младших частей.
      CBNL lp = p1 [n1];                        // Сохранение затираемого
      p1 [n1] = _CBNL_TAB_OPT + 1;              // слова и запоминание размера.
#ifdef  _CBIGNUM_SHIFTTAB_MUL
      if (n2 >= _CBNL_TAB_MIN) {                // Нужна таблица сдвигов?
        cBigNumberTab (p1 + n1);                // Подготовка таблицы сдвигов.
        cBigNumberMAddMulShlTab (p1 + n1, p2, k + n1, p);
      } else
#endif//_CBIGNUM_SHIFTTAB_MUL
        cBigNumberMAddMulShl (p1 + n1, p2, k + n1, p);
      p1 [n1 + 1] = 0;                          // Добавление старшего 0-слова.
      p1 [n1] = lp;                             // Восстановление слова.
    }
    while (n1 >= _CBNL_TAB_HIGH);
    p1 [0] = (CBNL)(n1 + 1);                    // Размер последней части.
  }
#endif//_CBIGNUM_BLOCK_MUL

//      Умножение последней части.

#ifdef  _CBIGNUM_SHIFTTAB_MUL
#ifdef  _CBIGNUM_BLOCK_MUL
  if (n2 >= _CBNL_TAB_MIN) {                    // Нужна таблица сдвигов?
#else
  if (n2 >= _CBNL_TAB_MIN && n1 <= _CBNL_TAB_HIGH) {
#endif//_CBIGNUM_BLOCK_MUL
    cBigNumberTab (p1);                         // Подготовка таблицы сдвигов.
    cBigNumberMAddMulShlTab (p1, p2, k, p);
  } else
#endif//_CBIGNUM_SHIFTTAB_MUL
    cBigNumberMAddMulShl (p1, p2, k, p);
}

void    cBigNumberMSubMulShlKar (               // Умножение с вычитанием
                                                // p -= p1 * p2 << k*BITS.
                        EXPTR(CBNL) p1,         // Множимое в перетираемом
                                                // буфере размера *p1 + 3 +
                                                // *p2 < _CBNL_TAB_MIN?
                                                //  (min (*p1, _CBNL_TAB_HIGH)
                                                //   + 2) * (BITS - 1).
                        EXPTR(CBNL) p2,         // Беззнаковый множитель.
                        size_t      k,          // Сдвиг произведения влево.
                        EXPTR(CBNL) p           // Вычитаемое в буфере размера
                                                // max (*p, *p1 + *p2 + k + 1)
                                                //                        + 2.
        )                                       // p1, p2 могут совпадать.
{
  assert (p1 != p);                             // Проверка несовпадения.
  assert (p2 != p);                             // Проверка несовпадения.
  size_t n1 = (size_t)(*p1);                    // Число слов.
  size_t n2 = (size_t)(*p2);                    // Число слов.

//      Проверка применимости метода Карацубы.

#ifdef  _CBIGNUM_KARATSUBA_MUL
  if (n1 > _CBNL_KARATSUBA_MIN && n2 > _CBNL_KARATSUBA_MIN)
  {

//      Умножение большого 1-го операнда по частям.
//      ПРИМЕЧАНИЕ: Алгоритм требует сохранения p2 при рекурсивном вызове.

    while (n1 > n2 * 2 - n2 / 4)                // Проверка размера.
    {
      CBNL lp = p1 [n1 -= n2];                  // Сохранение затираемого
      p1 [n1] = (CBNL) n2;                      // слова и запоминание размера.
      cBigNumberMSubMulShlKar (p1 + n1, p2, k + n1, p);
      p1 [n1] = lp;                             // Восстановление слова.
      p1 [n1 + 1] = 0; n1 += (lp < 0);          // Добавление старшего 0-слова.
      p1 [0] = (CBNL) n1;                       // Размер последней части.
    }

//      Умножение операндов близкого размера по методу Карацубы.

    size_t n = (n1 >= n2? n1: n2 - 1) / 2;      // Размер младшей части.

//      ПРИМЕЧАНИЕ: Чтобы не было переполнения p в редком специальном
//                  случае, когда p1 вдвое короче p2 или еще меньше,
//                  старшая часть p2 должна быть длиннее младшей части p2.

    cBigTemp c12; c12.checkexpand (n * 2 + 5);
    EXPTR(CBNL) p12 = EXPTRTYPE(c12);           // Буфер для умножения.

    cBigTemp c1; c1.checkexpand (n + 2);
    cBigTemp c2; c2.checkexpand (n + 4);
    cBigNumberCopyShr (p2, n, EXPTRTYPE(c2));   // Старшая часть p2 в c2.

//      Размер p1 может быть n или меньше если p1 вдвое или более короче p2.
//      ПРИМЕЧАНИЕ: Алгоритм требует сохранения c2 при рекурсивном вызове.

    if (n1 > n)
    {
      cBigNumberCopyShr (p1, n, EXPTRTYPE(c1)); // Старшая часть p1 в c1.
      CBNL lp = p1 [n];                         // Сохранение затираемого
      p1 [n] = (CBNL)(n1 - n);                  // слова и запоминание размера.
      p12 [0] = 0;                              // Очистка буфера умножения.
      cBigNumberMAddMulShlKar (p1 + n, EXPTRTYPE(c2), 0, p12);
                                                // Умножение c1 * c2.
      cBigNumberMSubShl (p, p12, k + n * 2);    // Накопление c1 * c2.
      cBigNumberMAddShl (p, p12, k + n);        // Накопление c1 * c2.
      p1 [n] = lp;                              // Восстановление слова.
      p1 [n + 1] = 0;                           // Добавление старшего 0-слова.
      p1 [0] = (CBNL)(n + (lp < 0));            // Младшая часть p1.
      cBigNumberMAddShl (EXPTRTYPE(c1), p1, 0); // Сложение c1 + p1.
    }
    else
      cBigNumberCopy (p1, EXPTRTYPE(c1));       // Копирование p1 в c1.

//      Размер p2 не может быть n или меньше.

    assert (n2 > n);
    {
      size_t nc2 = c2.length() + 1;             // Добавление старшего 0-слова.
      c2.item (0) = (CBNL) nc2;
      ((EXPTR(CBNL)) EXPTRTYPE(c2)) [nc2] = 0;

      CBNL lp = p2 [n + 1];                     // Сохранение слова.
      p2 [n + 1] = 0;                           // Добавление старшего 0-слова.
      p2 [0] = (CBNL)(n + 1);                   // Младшая часть p2.
      cBigNumberMAddShl (EXPTRTYPE(c2), p2, 0); // Сложение c2 + p2.
      p2 [n + 1] = lp;                          // Восстановление слова.

      p2 [0] = (CBNL) n;                        // Удаление старшего 0-слова.
      p12 [0] = 0;                              // Очистка буфера результата.
      cBigNumberMAddMulShlKar (p1, p2, 0, p12); // Умножение p1 * p2.
      p2 [0] = (CBNL) n2;                       // Восстановление исходного p2.

      c2.item (0) = (CBNL)(c2.length() - (c2.hiword() == 0));
                                                // Удаление старшего 0-слова.
      cBigNumberCopy (CBPTRTYPE(c1), p1);       // Накопление (c1+p2)*(c2+p2).
      cBigNumberMSubMulShlKar (p1, EXPTRTYPE(c2), k + n, p);

      cBigNumberMAddShl (p, p12, k + n);        // Накопление p1 * p2.
      cBigNumberMSubShl (p, p12, k);            // Накопление p1 * p2.
    }

    return;
  }
#endif//_CBIGNUM_KARATSUBA_MUL

//      Умножение 1-го операнда по частям, если 2-ой операнд небольшой.
//
//      Старшая часть может быть положительной или отрицательной, но младшие
//      части всегда положительные, поэтому добавляем к ним старшее 0-слово.
//      Старшая и последующие части содержат _CBNL_TAB_OPT + 1 слов,
//      включая старшее 0-слово для всех частей кроме старшей, самая
//      младшая часть может содержать до _CBNL_TAB_HIGH слов вместе со
//      добавочным старшим 0-словом.
//
//      Алгоритм выделяет части без копирования.

#ifdef  _CBIGNUM_BLOCK_MUL
  if (n1 > _CBNL_TAB_HIGH)
  {                                             // Учет старшего слова
    --n1;                                       // старшей части.
    do                                          // Цикл по частям.
    {
      n1 -= _CBNL_TAB_OPT;                      // Размер всех младших частей.
      CBNL lp = p1 [n1];                        // Сохранение затираемого
      p1 [n1] = _CBNL_TAB_OPT + 1;              // слова и запоминание размера.
#ifdef  _CBIGNUM_SHIFTTAB_MUL
      if (n2 >= _CBNL_TAB_MIN) {                // Нужна таблица сдвигов?
        cBigNumberTab (p1 + n1);                // Подготовка таблицы сдвигов.
        cBigNumberMSubMulShlTab (p1 + n1, p2, k + n1, p);
      } else
#endif//_CBIGNUM_SHIFTTAB_MUL
        cBigNumberMSubMulShl (p1 + n1, p2, k + n1, p);
      p1 [n1 + 1] = 0;                          // Добавление старшего 0-слова.
      p1 [n1] = lp;                             // Восстановление слова.
    }
    while (n1 >= _CBNL_TAB_HIGH);
    p1 [0] = (CBNL)(n1 + 1);                    // Размер последней части.
  }
#endif//_CBIGNUM_BLOCK_MUL

//      Умножение последней части.

#ifdef  _CBIGNUM_SHIFTTAB_MUL
#ifdef  _CBIGNUM_BLOCK_MUL
  if (n2 >= _CBNL_TAB_MIN) {                    // Нужна таблица сдвигов?
#else
  if (n2 >= _CBNL_TAB_MIN && n1 <= _CBNL_TAB_HIGH) {
#endif//_CBIGNUM_BLOCK_MUL
    cBigNumberTab (p1);                         // Подготовка таблицы сдвигов.
    cBigNumberMSubMulShlTab (p1, p2, k, p);
  } else
#endif//_CBIGNUM_SHIFTTAB_MUL
    cBigNumberMSubMulShl (p1, p2, k, p);
}

//      Универсальные функции умножения работают с числами любых знаков.
//      Для ускорения умножения функции могут использовать метод Карацубы
//      и строить временные таблицы сдвигов.
//
//      Для лучшей производительности операнд существенно большего
//      размера рекомендуется поставить первым.
//
//      Функции не требуют нормализации операндов и всегда выдают
//      нормализованный результат.

void    cBigNumberMAddMul (                     // Умножение со сложением
                                                // p += p1 * p2.
                const   CBPTR(CBNL) p1,         // Множимое.
                const   CBPTR(CBNL) p2,         // Множитель.
                        EXPTR(CBNL) p           // Слагаемое в буфере размера
                                                // max (*p, *p1 + *p2 + 1) + 2.
        )                                       // p1, p2, p могут совпадать.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.

  cBigTemp cBigBuf1;                            // Выделение временного буфера.
  cBigTemp cBigBuf2;                            // Выделение временного буфера.
  cBigBuf1.checkexpand ((n2 < _CBNL_TAB_MIN)? (n1 + 2):
                        (n1 < _CBNL_TAB_HIGH)? ((n1 + 3) * BITS + 1):
                          (n1 + 2 + (_CBNL_TAB_HIGH + 2) * BITS + 1));
  cBigBuf2.checkexpand (n2 + 1);                // Распределение памяти.
  EXPTR(CBNL) pp1 = EXPTRTYPE(cBigBuf1);        // Буфер для множимого.
  EXPTR(CBNL) pp2 = EXPTRTYPE(cBigBuf2);        // Буфер для множителя.

//      Копирование и нормализация ненулевого множителя с пропуском
//      младших 0-слов. Если множитель 0, то результат содержит 0 слов.

  size_t k = cBigNumberCopySkipLow0 (p1, pp1);  // Copying of multiplicand.

  if (CBPTRBASE(p2)[n2] >= 0)                   // Множитель неотрицателен:
  {
    cBigNumberCopy (p2, pp2);                   // Копирование.
    cBigNumberMAddMulShlKar (pp1, pp2, k, p);   // Оптимизированное умножение.
  }
  else                                          // Множитель отрицателен:
  {
    cBigNumberNeg (p2, pp2);                    // Смена знака.
    *pp2 = (CBNL)n2;                            // Не увеличиваем размер.
    cBigNumberMSubMulShlKar (pp1, pp2, k, p);   // Оптимизированное умножение.
  }
}

void    cBigNumberMSubMul (                     // Умножение с вычитанием
                                                // p -= p1 * p2.
                const   CBPTR(CBNL) p1,         // Множимое.
                const   CBPTR(CBNL) p2,         // Множитель.
                        EXPTR(CBNL) p           // Вычитаемое в буфере размера
                                                // max (*p, *p1 + *p2 + 1) + 2.
        )                                       // p1, p2, p могут совпадать.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.

  cBigTemp cBigBuf1;                            // Выделение временного буфера.
  cBigTemp cBigBuf2;                            // Выделение временного буфера.
  cBigBuf1.checkexpand ((n2 < _CBNL_TAB_MIN)? (n1 + 2):
                        (n1 < _CBNL_TAB_HIGH)? ((n1 + 3) * BITS + 1):
                          (n1 + 2 + (_CBNL_TAB_HIGH + 2) * BITS + 1));
  cBigBuf2.checkexpand (n2 + 1);                // Распределение памяти.
  EXPTR(CBNL) pp1 = EXPTRTYPE(cBigBuf1);        // Буфер для множимого.
  EXPTR(CBNL) pp2 = EXPTRTYPE(cBigBuf2);        // Буфер для множителя.

//      Копирование и нормализация ненулевого множителя с пропуском
//      младших 0-слов. Если множитель 0, то результат содержит 0 слов.

  size_t k = cBigNumberCopySkipLow0 (p1, pp1);  // Copying of multiplicand.

  if (CBPTRBASE(p2)[n2] >= 0)                   // Множитель неотрицателен:
  {
    cBigNumberCopy (p2, pp2);                   // Копирование.
    cBigNumberMSubMulShlKar (pp1, pp2, k, p);   // Оптимизированное умножение.
  }
  else                                          // Множитель отрицателен:
  {
    cBigNumberNeg (p2, pp2);                    // Смена знака.
    *pp2 = (CBNL)n2;                            // Не увеличиваем размер.
    cBigNumberMAddMulShlKar (pp1, pp2, k, p);   // Оптимизированное умножение.
  }
}

void    cBigNumberMul (                         // Умножение p = p1 * p2.
                const   CBPTR(CBNL) p1,         // Множимое.
                const   CBPTR(CBNL) p2,         // Множитель.
                        EXPTR(CBNL) p           // Буфер размера
                                                // *p1 + *p2 + 3.
        )                                       // p1, p2, p могут совпадать.
{
  size_t n1 = (size_t)(*CBPTRBASE(p1));         // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.

  cBigTemp cBigBuf1;                            // Выделение временного буфера.
  cBigTemp cBigBuf2;                            // Выделение временного буфера.
  cBigBuf1.checkexpand ((n2 < _CBNL_TAB_MIN)? (n1 + 2):
                        (n1 < _CBNL_TAB_HIGH)? ((n1 + 3) * BITS + 1):
                          (n1 + 2 + (_CBNL_TAB_HIGH + 2) * BITS + 1));
  cBigBuf2.checkexpand (n2 + 1);                // Распределение памяти.
  EXPTR(CBNL) pp1 = EXPTRTYPE(cBigBuf1);        // Буфер для множимого.
  EXPTR(CBNL) pp2 = EXPTRTYPE(cBigBuf2);        // Буфер для множителя.

//      Копирование и нормализация ненулевого множителя с пропуском
//      младших 0-слов. Если множитель 0, то результат содержит 0 слов.

  size_t k = cBigNumberCopySkipLow0 (p1, pp1);  // Copying of multiplicand.

//      Обнуление результата - единственное различие между cBigNumberMul()
//      и cBigNumberMAddMul(). Результат можно обнулить после копирования
//      чисел, поскольку операнды могут перекрываться.

  if (CBPTRBASE(p2)[n2] >= 0)                   // Множитель неотрицателен:
  {
    cBigNumberCopy (p2, pp2);                   // Копирование.
    p [0] = 0;                                  // Обнуление произведения.
    cBigNumberMAddMulShlKar (pp1, pp2, k, p);   // Оптимизированное умножение.
  }
  else                                          // Множитель отрицателен:
  {
    cBigNumberNeg (p2, pp2);                    // Смена знака.
    *pp2 = (CBNL)n2;                            // Не увеличиваем размер.
    p [0] = 0;                                  // Обнуление произведения.
    cBigNumberMSubMulShlKar (pp1, pp2, k, p);   // Оптимизированное умножение.
  }
}

//      Функция умножения чисел CBNL.

void   _CBNL_C  cLongMul (                      // Умножение p = p1 * p2.
                        CBNL    l1,             // Множимое.
                        CBNL    l2,             // Множитель.
                        CBNL    p [2]           // Результат.
        )
{
  CBNL c1 [5]; c1 [0] = 1; c1 [1] = l1;         // Буфер для множимого.
  CBNL c2 [3]; c2 [0] = 1; c2 [1] = l2;         // Буфер для множителя.
  CBNL c  [5]; c [0] = c [1] = c [2] = 0;       // Буфер для результата.
  EXPTR(CBNL) pp1 = EXPTRTO(CBNL,c1,sizeof(c1)/sizeof(*c1)-1);
  EXPTR(CBNL) pp2 = EXPTRTO(CBNL,c2,sizeof(c2)/sizeof(*c2)-1);
  EXPTR(CBNL) pp  = EXPTRTO(CBNL,c, sizeof(c) /sizeof(*c) -1);

  if (l2 >= 0)                                  // Множитель неотрицателен:
    cBigNumberMAddMulShl (pp1, pp2, 0, pp);     // Умножение.
  else {                                        // Множитель отрицателен:
    c2 [1] = -l2;                               // Смена знака.
    cBigNumberMSubMulShl (pp1, pp2, 0, pp);     // Умножение.
  }

  p [0] = pp [1];
  p [1] = pp [2];
}

//      Функция умножения чисел unsigned CBNL.

void   _CBNL_C  cULongMul (                     // Умножение p = p1 * p2.
                unsigned CBNL   l1,             // Беззнаковое множимое.
                unsigned CBNL   l2,             // Беззнаковый множитель.
                unsigned CBNL   p [2]           // Результат.
        )
{                                               // Буфер для множимого.
  CBNL c1 [5]; c1 [0] = 2; c1 [1] = l1; c1 [2] = 0;
  CBNL c2 [3]; c2 [0] = 1; c2 [1] = l2;         // Буфер для множителя.
  CBNL c  [6]; c [0] = c [1] = c [2] = 0;       // Буфер для результата.
  EXPTR(CBNL) pp1 = EXPTRTO(CBNL,c1,sizeof(c1)/sizeof(*c1)-1);
  EXPTR(CBNL) pp2 = EXPTRTO(CBNL,c2,sizeof(c2)/sizeof(*c2)-1);
  EXPTR(CBNL) pp  = EXPTRTO(CBNL,c, sizeof(c) /sizeof(*c) -1);

  cBigNumberMAddMulShl (pp1, pp2, 0, pp);       // Умножение.

  p [0] = pp [1];
  p [1] = pp [2];
}

#endif//_CBIGNUM_HARDWARE_MUL

//================================================
//      Функция, обрабатывающая деление на 0.
//================================================

size_t  cBigNumberMaskDiv0;                     // Маска деления на 0:
                                                //  0 - Divide Error
void    cBigNumberDiv0()                        // >0 - игнорировать
{
  cBigNumberMaskDiv0 /= cBigNumberMaskDiv0;
}

//================================================
//      Функции целочисленного деления.
//================================================

//      Специализированная функция деления с таблицей сдвигов.
//      Предполагается, что делимое и делитель имеют одинаковый знак,
//      за исключением случая деления отрицательного числа на 0.
//      В буфере делителя должна находиться таблица сдвигов,
//      полученная функцией cBigNumberTab.
//
//      Функция определяет частное и заносит остаток на место делимого.
//      Частное >= 0. Знак остатка совпадает со знаком делимого.
//      При делении на 0, если оно разрешено, частное равно 0,
//      остаток равен делимому.
//
//      Делимое должно быть нормализованным.
//      Функция выдает нормализованные частное и остаток.

void    cBigNumberMModDivShlTab (               // Деление
                                                // p = p1 / p2 << k2*BITS,
                                                //    p1 %= p2 << k2*BITS.
                        EXPTR(CBNL) p1,         // Делимое, потом остаток.
                const   CBPTR(CBNL) p2,         // Делитель и таблица сдвигов.
                        size_t      k2,         // Сдвиг делителя влево.
                        EXPTR(CBNL) p           // Буфер размера *p1 + 2.
        )                                       // p1,p2,p не могут совпадать.
{
  assert (cBigNumberIsFit (p1));                // Проверка нормализованности.
  assert (p1 != p);                             // Проверка несовпадения.
  assert (p2 != p);                             // Проверка несовпадения.
  assert (p2 != p1);                            // Проверка несовпадения.
  size_t n1 = (size_t)(*p1);                    // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.
  size_t n = n2 + k2;                           // Число слов после сдвига.
  if (n > n1) n = n1; n = n1 - n + 1;           // Счетчик слов в частном.

//      К частному надо добавить нулевое слово на тот случай,
//      если старший бит частного будет установлен в единицу.
//      Если нулевое слово будет лишним, то оно будет удалено
//      при нормализации.

  *p = (CBNL)(n + 1); p += n; p [1] = 0;        // Начало заполнения p.

//      Строим остальные слова.

  if (n2 >= cBigNumberSkipLow0 (p2))            // Пропуск младших 0-слов.
  {                                             // Проверка деления на 0.
    assert ((p1 [n1] ^ CBPTRBASE(p2)[n2]) >= 0);// Совпадение знаков.
    CBNL lt = (CBPTRBASE(p2)[n2] < 0) * 2 - 1;  // Константа для сравнения
                                                // абсолютных значений чисел.
                                                // (p1 и p2 >= 0)? -1: 1
    n2 += 2;                                    // Шаг таблицы сдвигов.
    do                                          // Цикл по словам частного.
    {
      --n;                                      // Счетчик слов частного.
      p2 += n2 * BITS;                          // Сдвиг делителя на слово.
      unsigned CBNL mask = (unsigned CBNL)      // Начальная маска.
                        (((CBNL)1) << (BITS-1));
      *p = 0;                                   // Обнуление слова частного.
      do                                        // Цикл по битам частного.
      {
        p2 -= n2;                               // Текущий сдвиг.
        CBNL diff = (CBNL)(n + k2) - *p1 + *p2; // Разность размеров.
        if (diff <= 0 && (diff < 0 ||           // Если остаток не меньше
            cBigNumberCompHigh (p1, p2) != lt)) // сдвинутого делителя,
        {                                       // то проводится
          cBigNumberMSubD (p1, p2, n + k2);     // вычитание делителя и
          (*p) += mask;                         // установка бита частного.
        }
      }
      while ((mask >>= 1) != 0);                // Конец цикла по битам.
      --p;                                      // Слово частного сформировано.
    }
    while (n);                                  // Конец цикла по словам.
    assert ((p1 [(size_t)(*p1)] ^ lt) < 0 ||    // Совпадение знаков или
            (p1 [(size_t)(*p1)] + *p1) == 1);   // равенство остатка 0.
//  assert (cBigNumberComp (p1, p2) == lt);     // Остаток меньше делителя.
    assert (cBigNumberIsFit (p1));              // Проверка нормализованности.
  }
  else                                          // Делитель 0.
  {                                             // Если деление на 0
    cBigNumberDiv0();                           // разрешено, то остаток
    do { *p-- = 0; } while (--n);               // будет равен делимому.
  }

  cBigNumberFit (p);                            // Нормализация частного.
  assert (p [(size_t)(*p)] >= 0);               // Проверка неотрицательности.
#ifndef _CBIGNUM_MT
  _cBigNumberSkip = 1;                          // Не пропускать 0-слова.
#endif//_CBIGNUM_MT
}

//      Универсальная функция деления работает с числами любых знаков и
//      не требует наличия предварительно подготовленной таблицы сдвигов.
//      Если это ускоряет операцию, то функция сама строит временную таблицу
//      сдвигов, иначе применяет алгоритм, не использующий таблицу сдвигов.
//
//      Функция определяет частное и заносит остаток на место делимого.
//      Знак частного - это произведение знаков делимого и делителя.
//      Знак остатка совпадает со знаком делимого.
//      При делении на 0, если оно разрешено, частное равно 0,
//      остаток равен делимому.
//
//      Делимое должно быть нормализованным.
//      Функция выдает нормализованные частное и остаток.

void    cBigNumberMModDiv (                     // Деление p = p1 / p2,
                                                //         p1 %= p2.
                        EXPTR(CBNL) p1,         // Делимое, потом остаток.
                const   CBPTR(CBNL) p2,         // Делитель.
                        EXPTR(CBNL) p           // Буфер размера *p1 + 3.
        )                                       // p2 может совпадать с p1, p.
{
  assert (p1 != p);                             // Проверка несовпадения.
  size_t n1 = (size_t)(*p1);                    // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.

  cBigTemp cBigBuf2;                            // Выделение временного буфера.
#ifdef  _CBIGNUM_SHIFTTAB_DIV
  CBNL nt = (CBNL)((n2 - n1 + _CBNL_TAB_MIN - 1) & (n2 - _CBNL_TAB_MAX));
  cBigBuf2.checkexpand ((size_t)((nt < 0)? ((n2 + 3) * BITS + 1): (n2 + 3)));
#else //_CBIGNUM_SHIFTTAB_DIV
  cBigBuf2.checkexpand ((size_t)(n2 + 3));
#endif//_CBIGNUM_SHIFTTAB_DIV
  EXPTR(CBNL) pp2 = EXPTRTYPE(cBigBuf2);        // Буфер для делителя.

//      Копирование и нормализация ненулевого делителя с пропуском младших 0-слов.
//      Если делитель 0, то результат содержит 0 слов.

  size_t k2 = cBigNumberCopySkipLow0 (p2, pp2); // Копирование делителя.

//      Обеспечиваем совпадение знаков делимого и делителя.

  CBNL signquot = p1 [n1] ^ CBPTRBASE(p2)[n2];  // Знак ненулевого частного.
  if (signquot < 0) cBigNumberNeg (pp2, pp2);   // Смена знака делителя.

//      Алгоритм с таблицей сдвигов.

#ifdef  _CBIGNUM_SHIFTTAB_DIV
  if (nt < 0)
  {
    cBigNumberTab (pp2);                        // Подготовка таблицы сдвигов.
    cBigNumberMModDivShlTab (p1, pp2, k2, p);   // Деление.
    if (signquot < 0) cBigNumberNeg (p, p);     // Смена знака частного.
    return;
  }
#endif//_CBIGNUM_SHIFTTAB_DIV

//      Алгоритм, не применяющий таблицу сдвигов.

  n2 = (size_t)(*pp2);                          // Число слов.
  if (n2 == 0)                                  // Делитель 0.
  {                                             // Если деление на 0
    cBigNumberDiv0();                           // разрешено, то остаток
    p [0] = 1; p [1] = 0;                       // будет равен делимому
    return;                                     // и частное равно 0.
  }
  assert (cBigNumberIsFit (p1));                // Проверка нормализованности.
  assert (cBigNumberIsFit (pp2));               // Проверка нормализованности.

  size_t n = n2 + k2;                           // Число слов после сдвига.

  if (n2 > 1 || n != n1)                        // Общий случай деления.
  {
    if (n > n1)                                 // Если делимое короче
    {                                           // делителя, то остаток
      p [0] = 1; p [1] = 0;                     // будет равен делимому
      return;                                   // и частное равно 0.
    }
    n = n1 - n + 1;                             // Счетчик слов в частном.

//      К частному надо добавить нулевое слово на тот случай,
//      если старший бит частного будет установлен в единицу.
//      Если нулевое слово будет лишним, то оно будет удалено
//      при нормализации.

    *p = (CBNL)(n + 1); p += n; p [1] = 0;      // Начало заполнения p.

//      Строим остальные слова.

    assert ((p1 [n1] ^ pp2 [n2]) >= 0);         // Проверка совпадения знаков.
    CBNL lt = (pp2 [n2] < 0) * 2 - 1;           // Константа для сравнения
                                                // абсолютных значений чисел
                                                // (p1 и pp2 >= 0)? -1: 1
    do                                          // Цикл по словам частного.
    {
      --n;                                      // Счетчик слов частного.
      *p = 0;                                   // Обнуление слова частного.
      cBigNumberMShlD (pp2);                    // Сдвиг делителя на слово.
      unsigned CBNL mask = ((unsigned CBNL)1)   // Начальная маска.
                            << (BITS-1);
      do                                        // Цикл по битам частного.
      {
        CBNL diff = (CBNL)cBigNumberMDiv2D (pp2)// Сдвиг делителя на бит.
                  + (CBNL)(n + k2) - *p1;       // Разность размеров.
        if (diff <= 0 && (diff < 0 ||           // Если остаток не меньше
            cBigNumberCompHigh (p1, pp2) != lt))// сдвинутого делителя,
        {                                       // то проводится
          cBigNumberMSubD (p1, pp2, n + k2);    // вычитание делителя и
          (*p) += mask;                         // установка бита частного.
        }
      }
      while ((mask >>= 1) != 0);                // Конец цикла по битам.
      --p;                                      // Слово частного сформировано.
    }
    while (n);                                  // Конец цикла по словам.
    assert ((p1 [(size_t)(*p1)] ^ lt) < 0 ||    // Совпадение знаков или
            (p1 [(size_t)(*p1)] + *p1) == 1);   // равенство остатка 0.
//  assert (cBigNumberComp (p1, pp2) == lt);    // Остаток меньше делителя.
    assert (cBigNumberIsFit (p1));              // Проверка нормализованности.
    cBigNumberFit (p);                          // Нормализация частного.
  }
  else                                          // Однословное деление.
  {
    CBNL p1n = p1 [n1];                         // Слово делимого.
    CBNL p2n = pp2 [n2];                        // Слово делителя.
    assert ((p1n ^ p2n) >= 0);                  // Проверка совпадения знаков.
    assert (p2n != 0);                          // Проверка деления не на 0.

#ifndef _CBIGNUM_HARDWARE_DIV
    CBNL pn = 0;                                // Обнуление слова частного.
    int nb = cLongBits (p1n) - cLongBits (p2n); // Разность в числе значащих
    if (nb >= 0)                                // бит должна быть >= 0.
    {
      unsigned CBNL mask = ((unsigned CBNL)1)   // Маска.
                            << nb;              // Выравнивание
      p2n <<= nb;                               // делителя к делимому.

      if (p2n > 0)                              // Положительный делитель.
      {
        for (;; p2n >>= 1)                      // Цикл по оставшимся
        {                                       // битам частного.
#ifdef  _CBIGNUM_REDUCE_JUMPS
          CBNL m = ((p1n < p2n) - 1);           // Если остаток не меньше,
          p1n -= p2n & m;                       // то вычитание делителя и
          pn += mask & m;                       // установка бита частного.
#else //_CBIGNUM_REDUCE_JUMPS
          if (p1n >= p2n)                       // Если остаток не меньше
          {                                     // сдвинутого делителя,
            p1n -= p2n;                         // то вычитание делителя и
            pn += mask;                         // установка бита частного.
          }
#endif//_CBIGNUM_REDUCE_JUMPS
          if ((mask >>= 1) == 0) break;
        }                                       // Конец цикла по битам.
      }
      else                                      // Отрицательный делитель.
      {
        for (;; p2n >>= 1)                      // Цикл по оставшимся
        {                                       // битам частного.
#ifdef  _CBIGNUM_REDUCE_JUMPS
          CBNL m = ((p1n > p2n) - 1);           // Если остаток не меньше,
          p1n -= p2n & m;                       // то вычитание делителя и
          pn += mask & m;                       // установка бита частного.
#else //_CBIGNUM_REDUCE_JUMPS
          if (p1n <= p2n)                       // Если остаток не меньше
          {                                     // сдвинутого делителя,
            p1n -= p2n;                         // то вычитание делителя и
            pn += mask;                         // установка бита частного.
          }
#endif//_CBIGNUM_REDUCE_JUMPS
          if ((mask >>= 1) == 0) break;
        }                                       // Конец цикла по битам.
        if (p1n == 0)                           // Случай отрицательного
        {                                       // делителя с ненулевыми
          for (size_t n = n1; --n > 0;)         // младшими словами.
          {
            if (p1 [n] != 0) { pn--; p1n += p2n; break; }
          }
        }
      }
    }
#else //_CBIGNUM_HARDWARE_DIV
    CBNL pn;
    if (p1n != CBNL_MIN || p2n != -1)            // Обход ошибки CPU.
    {
      pn = p1n / p2n;                            // Частное.
      p1n -= pn * p2n;                           // Остаток.
    }
    else                                         // CBNL_MIN/-1.
    {
      pn = p1n;                                  // -Частное.
      p1n = 0;                                   // Остаток.
    }
    if (p2n < 0 && p1n == 0)                     // Случай отрицательного
    {                                            // делителя с ненулевыми
      for (size_t n = n1; --n > 0;)              // младшими словами.
      {
        if (p1 [n] != 0) { pn--; p1n += p2n; break; }
      }
    }
#endif//_CBIGNUM_HARDWARE_DIV

    p [0] = 1; p [1] = pn;                      // Запоминание частного.
    if (pn < 0) { p [0] = 2; p [2] = 0; }       // Коррекция для CBNL_MIN/-1.
    p1 [n1] = p1n;                              // Запоминание остатка.
    cBigNumberFit (p1);                         // Нормализация.
    assert ((p1 [(size_t)(*p1)] ^ pp2 [n2]) >= 0// Совпадение знаков или
         || (p1 [(size_t)(*p1)] + *p1) == 1);   // равенство остатка 0.
    assert (cBigNumberIsFit (p));               // Проверка нормализованности.
  }

  assert (p [(size_t)(*p)] >= 0);               // Проверка неотрицательности.
  if (signquot < 0) cBigNumberNeg (p, p);       // Смена знака частного.
}

//================================================
//      Функции вычисления остатка.
//================================================

//      Специализированная функция остатка с таблицей сдвигов.
//      Предполагается, что делимое и делитель имеют одинаковый знак,
//      за исключением случая деления отрицательного числа на 0.
//      В буфере делителя должна находиться таблица сдвигов,
//      полученная функцией cBigNumberTab.
//
//      Функция вычисления остатка является сокращенным вариантом
//      функции деления, из которой исключено вычисление частного.
//      Функция заносит остаток на место делимого.
//      Знак остатка совпадает со знаком делимого.
//      При делении на 0, если оно разрешено, остаток равен делимому.
//
//      Делимое должно быть нормализованным.
//      Функция выдает нормализованный остаток.

void    cBigNumberMModShlTab (                  // Остаток p1 %= p2<< k2*BITS.
                        EXPTR(CBNL) p1,         // Делимое, потом остаток.
                const   CBPTR(CBNL) p2,         // Делитель и таблица сдвигов.
                        size_t      k2          // Сдвиг делителя влево.
        )                                       // p1, p2 не могут совпадать.
{
  assert (cBigNumberIsFit (p1));                // Проверка нормализованности.
  assert (p1 != p2);                            // Проверка несовпадения.
  size_t n1 = (size_t)(*p1);                    // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.
  size_t n = n2 + k2;                           // Число слов после сдвига.
  if (n > n1) n = n1; n = n1 - n + 1;           // Счетчик слов в частном.

  if (n2 >= cBigNumberSkipLow0 (p2))            // Пропуск младших 0-слов.
  {                                             // Проверка деления на 0.
    assert ((p1 [n1] ^ CBPTRBASE(p2)[n2]) >= 0);// Совпадение знаков.
    CBNL lt = (CBPTRBASE(p2)[n2] < 0) * 2 - 1;  // Константа для сравнения
                                                // абсолютных значений чисел
                                                // (p1 и p2 >= 0)? -1: 1
    n2 += 2;                                    // Шаг таблицы сдвигов.
    do                                          // Цикл по словам частного.
    {
      --n;                                      // Счетчик слов частного.
      p2 += n2 * BITS;                          // Сдвиг делителя на слово.
      unsigned CBNL mask = (unsigned CBNL)      // Начальная маска.
                        (((CBNL)1) << (BITS-1));
      do                                        // Цикл по битам частного.
      {
        p2 -= n2;                               // Текущий сдвиг.
        CBNL diff = (CBNL)(n + k2) - *p1 + *p2; // Разность размеров.
        if (diff <= 0 && (diff < 0 ||           // Если остаток не меньше
            cBigNumberCompHigh (p1, p2) != lt)) // сдвинутого делителя,
        {                                       // то проводится
          cBigNumberMSubD (p1, p2, n + k2);     // вычитание делителя.
        }
      }
      while ((mask >>= 1) != 0);                // Конец цикла по битам.
    }
    while (n);                                  // Конец цикла по словам.
    assert ((p1 [(size_t)(*p1)] ^ lt) < 0 ||    // Совпадение знаков или
            (p1 [(size_t)(*p1)] + *p1) == 1);   // равенство остатка 0.
//  assert (cBigNumberComp (p1, p2) == lt);     // Остаток меньше делителя.
    assert (cBigNumberIsFit (p1));              // Проверка нормализованности.
  }
  else                                          // Делитель 0.
  {                                             // Если деление на 0
    cBigNumberDiv0();                           // разрешено, то остаток
  }                                             // будет равен делимому.

#ifndef _CBIGNUM_MT
  _cBigNumberSkip = 1;                          // Не пропускать 0-слова.
#endif//_CBIGNUM_MT
}

//      Универсальная функция остатка работает с числами любых знаков и
//      не требует наличия предварительно подготовленной таблицы сдвигов.
//      Если это ускоряет операцию, то функция сама строит временную таблицу
//      сдвигов, иначе применяет алгоритм, не использующий таблицу сдвигов.
//
//      Функция вычисления остатка является сокращенным вариантом
//      функции деления, из которой исключено вычисление частного.
//      Функция заносит остаток на место делимого.
//      Знак остатка совпадает со знаком делимого.
//      При делении на 0, если оно разрешено, остаток равен делимому.
//
//      Делимое должно быть нормализованным.
//      Функция выдает нормализованный остаток.

void    cBigNumberMMod (                        // Остаток p1 %= p2.
                        EXPTR(CBNL) p1,         // Делимое, потом остаток.
                const   CBPTR(CBNL) p2          // Делитель.
        )                                       // p1, p2 могут совпадать.
{
  size_t n1 = (size_t)(*p1);                    // Число слов.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.

  cBigTemp cBigBuf2;                            // Выделение временного буфера.
#ifdef  _CBIGNUM_SHIFTTAB_DIV
  CBNL nt = (CBNL)((n2 - n1 + _CBNL_TAB_MIN - 1) & (n2 - _CBNL_TAB_MAX));
  cBigBuf2.checkexpand ((size_t)((nt < 0)? ((n2 + 3) * BITS + 1): (n2 + 3)));
#else //_CBIGNUM_SHIFTTAB_DIV
  cBigBuf2.checkexpand ((size_t)(n2 + 3));
#endif//_CBIGNUM_SHIFTTAB_DIV
  EXPTR(CBNL) pp2 = EXPTRTYPE(cBigBuf2);        // Буфер для делителя.

//      Копирование и нормализация ненулевого делителя с пропуском младших 0-слов.
//      Если делитель 0, то результат содержит 0 слов.

  size_t k2 = cBigNumberCopySkipLow0 (p2, pp2); // Копирование делителя.

//      Обеспечиваем совпадение знаков делимого и делителя.

  if ((p1 [n1] ^ CBPTRBASE(p2)[n2]) < 0) cBigNumberNeg (pp2, pp2);

//      Алгоритм с таблицей сдвигов.

#ifdef  _CBIGNUM_SHIFTTAB_DIV
  if (nt < 0)
  {
    cBigNumberTab (pp2);                        // Подготовка таблицы сдвигов.
    cBigNumberMModShlTab (p1, pp2, k2);         // Деление.
    return;
  }
#endif//_CBIGNUM_SHIFTTAB_DIV

//      Алгоритм, не применяющий таблицу сдвигов.

  n2 = (size_t)(*pp2);                          // Число слов.
  if (n2 == 0)                                  // Делитель 0.
  {                                             // Если деление на 0
    cBigNumberDiv0();                           // разрешено, то остаток
    return;                                     // будет равен делимому.
  }
  assert (cBigNumberIsFit (p1));                // Проверка нормализованности.
  assert (cBigNumberIsFit (pp2));               // Проверка нормализованности.

  size_t n = n2 + k2;                           // Число слов после сдвига.

  if (n2 > 1 || n != n1)                        // Общий случай деления.
  {                                             // Если делимое короче
    if (n > n1) return;                         // делителя, то остаток
                                                // будет равен делимому.
    n = n1 - n + 1;                             // Счетчик слов в частном.

    assert ((p1 [n1] ^ pp2 [n2]) >= 0);         // Проверка совпадения знаков.
    CBNL lt = (pp2 [n2] < 0) * 2 - 1;           // Константа для сравнения
                                                // абсолютных значений чисел
                                                // (p1 и pp2 >= 0)? -1: 1
    do                                          // Цикл по словам частного.
    {
      --n;                                      // Счетчик слов частного.
      cBigNumberMShlD (pp2);                    // Сдвиг делителя на слово.
      unsigned CBNL mask = ((unsigned CBNL)1)   // Начальная маска.
                            << (BITS-1);
      do                                        // Цикл по битам частного.
      {
        CBNL diff = (CBNL)cBigNumberMDiv2D (pp2)// Сдвиг делителя на бит.
                  + (CBNL)(n + k2) - *p1;       // Разность размеров.
        if (diff <= 0 && (diff < 0 ||           // Если остаток не меньше
            cBigNumberCompHigh (p1, pp2) != lt))// сдвинутого делителя,
        {                                       // то проводится
          cBigNumberMSubD (p1, pp2, n + k2);    // вычитание делителя.
        }
      }
      while ((mask >>= 1) != 0);                // Конец цикла по битам.
    }
    while (n);                                  // Конец цикла по словам.
    assert ((p1 [(size_t)(*p1)] ^ lt) < 0 ||    // Совпадение знаков или
            (p1 [(size_t)(*p1)] + *p1) == 1);   // равенство остатка 0.
//  assert (cBigNumberComp (p1, pp2) == lt);    // Остаток меньше делителя.
    assert (cBigNumberIsFit (p1));              // Проверка нормализованности.
  }
  else                                          // Однословное деление.
  {
    CBNL p1n = p1 [n1];                         // Слово делимого.
    CBNL p2n = pp2 [n2];                        // Слово делителя.
    assert ((p1n ^ p2n) >= 0);                  // Проверка совпадения знаков.
    assert (p2n != 0);                          // Проверка деления не на 0.

#ifndef _CBIGNUM_HARDWARE_DIV
    int nb = cLongBits (p1n) - cLongBits (p2n); // Разность в числе значащих
    if (nb >= 0)                                // бит должна быть >= 0.
    {
      unsigned CBNL mask = ((unsigned CBNL)1)   // Маска.
                            << nb;              // Выравнивание
      p2n <<= nb;                               // делителя к делимому.

      if (p2n > 0)                              // Положительный делитель.
      {
        for (;; p2n >>= 1)                      // Цикл по оставшимся
        {                                       // битам частного.
#ifdef  _CBIGNUM_REDUCE_JUMPS
          CBNL m = ((p1n < p2n) - 1);           // Если остаток не меньше,
          p1n -= p2n & m;                       // то вычитание делителя и
#else //_CBIGNUM_REDUCE_JUMPS
          if (p1n >= p2n)                       // Если остаток не меньше
          {                                     // сдвинутого делителя,
            p1n -= p2n;                         // то вычитание делителя и
          }
#endif//_CBIGNUM_REDUCE_JUMPS
          if ((mask >>= 1) == 0) break;
        }                                       // Конец цикла по битам.
      }
      else                                      // Отрицательный делитель.
      {
        for (;; p2n >>= 1)                      // Цикл по оставшимся
        {                                       // битам частного.
#ifdef  _CBIGNUM_REDUCE_JUMPS
          CBNL m = ((p1n > p2n) - 1);           // Если остаток не меньше,
          p1n -= p2n & m;                       // то вычитание делителя и
#else //_CBIGNUM_REDUCE_JUMPS
          if (p1n <= p2n)                       // Если остаток не меньше
          {                                     // сдвинутого делителя,
            p1n -= p2n;                         // то вычитание делителя и
          }
#endif//_CBIGNUM_REDUCE_JUMPS
          if ((mask >>= 1) == 0) break;
        }                                       // Конец цикла по битам.
        if (p1n == 0)                           // Случай отрицательного
        {                                       // делителя с ненулевыми
          for (size_t n = n1; --n > 0;)         // младшими словами.
          {
            if (p1 [n] != 0) { p1n += p2n; break; }
          }
        }
      }
    }
#else //_CBIGNUM_HARDWARE_DIV
    if (p1n != CBNL_MIN || p2n != -1)            // Обход ошибки CPU.
    {
      p1n = p1n % p2n;                           // Остаток.
    }
    else                                         // CBNL_MIN/-1.
    {
      p1n = 0;                                   // Остаток.
    }
    if (p2n < 0 && p1n == 0)                     // Случай отрицательного
    {                                            // делителя с ненулевыми
      for (size_t n = n1; --n > 0;)              // младшими словами.
      {
        if (p1 [n] != 0) { p1n += p2n; break; }
      }
    }
#endif//_CBIGNUM_HARDWARE_DIV

    p1 [n1] = p1n;                              // Запоминание остатка.
    cBigNumberFit (p1);                         // Нормализация.
    assert ((p1 [(size_t)(*p1)] ^ pp2 [n2]) >= 0// Совпадение знаков или
         || (p1 [(size_t)(*p1)] + *p1) == 1);   // равенство остатка 0.
  }
}

//================================================
//      Функции возведения в степень.
//================================================

//      Функция возведения в степень использует буфер основания,
//      как рабочий и требует, чтобы он был такого же размера, как
//      буфер результата. Оба буфера должны вмещать результат и еще
//      иметь 2 дополнительных слова для нужд операции умножения.
//      Отметим, что если в p2 более одного слова и p1 отлично
//      от -1,0,1, то размер буферов будет больше 512 MБайт.
//
//      Функция не требует нормализации операндов и всегда выдает
//      нормализованный результат.

void    cBigNumberPow (                         // Возведение p1 в степень p2.
                        EXPTR(CBNL) p1,         // Основание в рабочем буфере
                                                // размера >= *p + 3.
                const   CBPTR(CBNL) p2,         // Показатель.
                        EXPTR(CBNL) p           // Буфер для результата
                                                // размера *p + 3.
        )                                       // p1,p2,p не могут совпадать.
{
  assert (p1 != p);                             // Проверка несовпадения.
  assert (p2 != p);                             // Проверка несовпадения.
  assert (p2 != p1);                            // Проверка несовпадения.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.

  p [0] = 1; p [1] = 1;                         // Начальная степень 1.

  if (CBPTRBASE(p2)[n2] < 0)                    // Отрицательный показатель?
  {
    cBigNumberFit (p1);                         // Нормализация.
    cBigNumberMModDiv (p, p1, p1);              // Целое частное 1/p1 или
    if (p1 [1] + (p2 [1] & 1) < 0) p1 [1] = 1;  // abs(1/p1) если p2 четное.
    p [1] = p1 [1];
  }
  else if (n2 != 0)                             // Степень может быть не 1?
  {
    p2++;                                       // Начало.
    for (;;)                                    // Цикл по словам p2.
    {
      CBNL num = *p2++;                         // Очередное слово p2.
      CBNL mask = 1;                            // Маска для битов num.
      if (--n2 == 0)                            // Сокращаем число проходов
      {                                         // на последнем цикле.
        if (num == 0) break;                    // Старшее слово p2 нулевое.
        do                                      // Старший бит num всегда 0.
          mask <<= 1;                           // Сдвигаем mask и num, пока
        while ((num <<= 1) > 0);                // старший бит num равен 0.
      }
      for (;;)                                  // Цикл по битам слова p2.
      {
        if (num & mask)
          cBigNumberMul (p1, p, p);             // Накопление степени.
        if ((mask <<= 1) == 0) break;           // Биты закончились.
        cBigNumberMul (p1, p1, p1);             // Квадрат основания.
      }                                         // Конец цикла по битам p2.
      if (n2 == 0) break;                       // Слова закончились.
      cBigNumberMul (p1, p1, p1);               // Квадрат основания.
    }                                           // Конец цикла по словам p2.
  }
}

//      Функция возведения в степень по модулю использует буфер основания,
//      как рабочий и требует, чтобы он был не меньше буфера результата.
//      Оба буфера должны быть вдвое больше буфера для модуля и
//      иметь дополнительное слово для нужд операции умножения.
//
//      Модуль должен быть ненулевым (если 0 и деление на 0 разрешено,
//      то результат будет 1).
//
//      Функция не требует нормализации операндов и всегда выдает
//      нормализованный результат.

void    cBigNumberPowMod (                      // Возведение p1 в степень p2.
                        EXPTR(CBNL) p1,         // Основание в рабочем буфере
                                                // размера >= *mod * 2 + 3.
                const   CBPTR(CBNL) p2,         // Показатель.
                const   CBPTR(CBNL) mod,        // Модуль (может совпадать).
                        EXPTR(CBNL) p           // Буфер для результата
                                                // размера *mod * 2 + 3.
        )                                       // p1,p2,p не могут совпадать.
{
  assert (p1 != p);                             // Проверка несовпадения.
  assert (p2 != p);                             // Проверка несовпадения.
  assert (p2 != p1);                            // Проверка несовпадения.
  size_t n2 = (size_t)(*CBPTRBASE(p2));         // Число слов.

  p [0] = 1; p [1] = 1;                         // Начальная степень 1.

  cBigNumberFit (p1);                           // Нормализация.
  if (CBPTRBASE(p2)[n2] < 0)                    // Отрицательный показатель?
  {
    cBigNumberMModDiv (p, p1, p1);              // Целое частное 1/p1 или
    if (p1 [1] + (p2 [1] & 1) < 0) p1 [1] = 1;  // abs(1/p1) если p2 четное.
    p [1] = p1 [1]; cBigNumberMMod (p, mod);    // Модуль степени.
    return;
  }

  cBigTemp cBigBuf3;                            // Выделение временного буфера.
  cBigBuf3.checkexpand (exmuladd (BITS, (size_t)(*CBPTRBASE(mod)),
                                  BITS * 3 + 1));
  EXPTR(CBNL) pmod = EXPTRTYPE(cBigBuf3);       // Буфер для модуля.

//      Копирование и нормализация ненулевого модуля с пропуском младших 0-слов.
//      Если делитель 0, то результат содержит 0 слов.

  size_t kmod = cBigNumberCopySkipLow0 (mod, pmod);

//      Проверяем деление на 0, обеспечиваем положительный знак модуля.
  {
    size_t nmod = (size_t)(*pmod);              // Число слов.
    if (nmod == 0) n2 = 0;                      // Деление на 0.
    if (pmod [nmod] < 0) cBigNumberNeg (pmod, pmod);
  }
//      Подготовка модуля для деления с таблицей сдвигов.

  cBigNumberTab (pmod);                         // Подготовка таблицы сдвигов.

//      Модуль начальной степени (0 если модуль 1, иначе 1),
//      также обработка деления на 0, если оно запрещено.

  cBigNumberMModShlTab (p, pmod, kmod);         // Модуль степени.

  if (n2 != 0 && p [1] != 0)                    // Степень может измениться?
  {
    p2++;                                       // Начало.

//      Делаем знак основания положительным (для деления с таблицей сдвигов).

    CBNL sign = p1 [(size_t)(*p1)];             // Знак основания.
    if (sign < 0)
    {
      cBigNumberNeg (p1, p1);                   // Смена знака основания.
      sign = (*p2 << (BITS-1));                 // Знак результата.
    }
    cBigNumberMModShlTab (p1, pmod, kmod);      // Модуль основания.

//      Возведение в степень по модулю.

    for (;;)                                    // Цикл по словам p2.
    {
      CBNL num = *p2++;                         // Очередное слово p2.
      CBNL mask = 1;                            // Маска для битов num.
      if (--n2 == 0)                            // Сокращаем число проходов
      {                                         // на последнем цикле.
        if (num == 0) break;                    // Старшее слово p2 нулевое.
        do                                      // Старший бит num всегда 0.
          mask <<= 1;                           // Сдвигаем mask и num, пока
        while ((num <<= 1) > 0);                // старший бит num равен 0.
      }
      for (;;)                                  // Цикл по битам слова p2.
      {
        if (num & mask)
        {                                       // Накопление степени.
          if (*p1 > *p) cBigNumberMul (p1, p, p);
          else          cBigNumberMul (p, p1, p);
          cBigNumberMModShlTab (p, pmod, kmod); // Модуль степени.
        }
        if ((mask <<= 1) == 0) break;           // Биты закончились.
        cBigNumberMul (p1, p1, p1);             // Квадрат основания.
        cBigNumberMModShlTab (p1, pmod, kmod);  // Модуль квадрата основания.
      }                                         // Конец цикла по битам p2.
      if (n2 == 0) break;                       // Слова закончились.
      cBigNumberMul (p1, p1, p1);               // Квадрат основания.
      cBigNumberMModShlTab (p1, pmod, kmod);    // Модуль квадрата основания.
    }                                           // Конец цикла по словам p2.
    if (sign < 0) cBigNumberNeg (p, p);         // Смена знака.
  }
}

//================================================
//      Функция целочисленного квадратного корня.
//================================================

//      Функция вычисляет целочисленный квадратный корень
//      и заносит остаток на место основания.
//      Если число бит > CBNL_MAX вызывается cBigNumberERange().
//
//      Основание должно быть нормализованным.
//      Функция всегда выдает нормализованный корень и остаток.

void    cBigNumberMRmSqrt (                     // Квадратный корень.
                        EXPTR(CBNL) p1,         // Основание, потом остаток.
                        EXPTR(CBNL) p           // Буфер размера *p1/2 + 2.
        )                                       // p1, p не могут совпадать.
{
  assert (cBigNumberIsFit (p1));                // Проверка нормализованности.
  assert (p1 != p);                             // Проверка несовпадения.
  size_t n1 = (size_t)(*p1);                    // Число слов.
  assert (p1 [n1] >= 0);                        // Проверка неотрицательности.

  cBigTemp cBigBuf2;                            // Выделение временного буфера.
  cBigBuf2.checkexpand (n1 + 1);                // +1 для отладочной проверки.
  EXPTR(CBNL) pp2 = EXPTRTYPE(cBigBuf2);        // Буфер для вычитаемого.
  *pp2 = 0;                                     // Обнуление.
  cBigNumberFitTo (pp2, n1);                    // Заполнение.
#ifndef _CBIGNUM_MT
  _cBigNumberSkip = 1;                          // Не пропускать 0-слова.
#endif//_CBIGNUM_MT

//      Алгоритм.

  CBNL nbit = (cBigNumberBits (p1) + 1) & ~1;
  if ((nbit -= 2) >= 0)
  {

//      Получение старшего бита вычитателя.

    {
      size_t nw = (size_t)(nbit / BITS);        // Слово.
      CBNL lw = (((CBNL)1) << (nbit % BITS));   // Маска.
      pp2 [nw + 1] += lw;                       // Установка бита.
      assert (pp2 [(size_t)(*pp2)] >= 0);       // Проверка неотрицательности.
      p1  [nw + 1] -= lw;                       // Вычитание без нормализации.
      assert (p1  [(size_t)(*p1)]  >= 0);       // Проверка неотрицательности.
    }

//      Обработка остальных битов вычитателя.
//      Вычитаемое и вычитатель пока не нормализованы, но будут
//      нормализованы при выполнении последующих операций.

    while ((nbit -= 2) >= 0)                    // Цикл по младшим битам.
    {
      size_t nw = (size_t)(nbit / BITS);        // Слово.
      CBNL lw = (((CBNL)1) << (nbit % BITS));   // Маска.
      pp2 [nw + 1] += lw;                       // Установка бита.
      if (cBigNumberComp (p1, pp2) < 0)         // Сравнение.
      {
        pp2 [nw] = (CBNL)(n1 - nw);             // Пропускаем младшие 0-слова.
        pp2 [nw + 1] -= lw;                     // Снятие бита.
        cBigNumberMDiv2D (pp2 + nw);            // Сдвиг вычитателя на бит.
      }
      else
      {
        pp2 [nw] = (CBNL)(n1 - nw);             // Пропускаем младшие 0-слова.
        cBigNumberMSubD (p1, pp2 + nw, nw);     // Коррекция остатка.
        assert (p1 [(size_t)(*p1)] >= 0);       // Проверка неотрицательности.
        assert (cBigNumberIsFit (p1));          // Проверка нормализованности.
        pp2 [nw + 1] -= lw;                     // Снятие бита.
        cBigNumberMDiv2D (pp2 + nw);            // Сдвиг вычитателя на бит.
        pp2 [nw + 1] += lw;                     // Установка бита.
      }
      n1 = (size_t)(pp2 [nw] + nw);             // Восстановление числа
      pp2 [nw] = 0;                             // после изменений для
      pp2 [0] = (CBNL)n1;                       // пропуска младших 0-слова.
      assert (pp2 [(size_t)(*pp2)] >= 0);       // Проверка неотрицательности.
      assert (cBigNumberIsFit (pp2));           // Проверка нормализованности.
    }
  }

  cBigNumberFit (pp2);                          // Нормализация корня.
  cBigNumberCopy (pp2, p);                      // Копирование корня.

//      Проверяем, что полученный корень дает наибольший квадрат,
//      не превосходящий по размеру заданное число.

  assert (cBigNumberComp ((cBigNumberMMul2M (pp2), pp2), p1) >= 0);
}

//================================================
//      Генератор случайных чисел.
//================================================

//      Генератор использует внешнюю функцию, возвращающую
//      случайное беззнаковое число с равномерным распределением
//      в диапазоне 0..ULONG_MAX.
//
//      В качестве результата формируется нормализованное случайное
//      значение с равномерным распределением для заданного числа бит.

void    cBigNumberRandom (                      // Случайное число.
                unsigned long (*pfnRand)(),     // Генератор случайных слов.
                unsigned CBNL lBits,            // Максимальное число бит.
                        EXPTR(CBNL) p           // Буфер размера lBits/BITS+1.
        )
{
  CBNL   l1 = lBits % BITS;                     // Число бит.
  size_t n1 = (size_t)(lBits / BITS + 1);       // Число слов.

  if (l1 != 0) l1 = cLongRandom (*pfnRand) &
                    ((unsigned CBNL)~0L >> (BITS-(size_t)l1));
  p [0] = (CBNL)n1;                             // Число слов.
  p [n1] = l1;                                  // Старшее слово.
  while (--n1 != 0) p [n1] = cLongRandom (*pfnRand);
                                                // Остальные слова.
  cBigNumberFit (p);                            // Нормализация.
  assert (p [(size_t)(*p)] >= 0);               // Проверка неотрицательности.
}

//      Формируется нормализованное случайное CBNL значение с
//      равномерным распределением,

#if UCBNL_MAX > ULONG_MAX                       // Inline если CBNL long.

#define LBITS   (CHAR_BIT * sizeof (long))

unsigned CBNL _CBNL_C cLongRandom (             // Случайное число.
                unsigned long (*pfnRand)()      // Генератор случайных слов.
)                                               // Выдает случайное число.
{
  unsigned CBNL temp = (*pfnRand)();
  int sh = LBITS; do temp |= (((CBNL)(*pfnRand)()) << LBITS); while ((sh += LBITS) < BITS);
  return (temp);
}

#endif

#ifdef  NCHECKPTR
#ifdef  __cplusplus
}
#endif//__cplusplus
#endif//NCHECKPTR

#endif//_CBIGNUMF_INL
