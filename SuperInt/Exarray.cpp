/* --------------------------------------------------------------
    Динамические массивы с проверкой индекса (версия 1.2c).
    Функции распределения памяти.

    http://www.imach.uran.ru/exarray

    Copyright 1998-2010, Р.Н.Шакиров, ИМаш УрО PAH.
    All Rights Reserved.

    Код предоставляется на условиях лицензии "public domain",
    т.е. допускается свободное применение, модификация и
    распространение кода при условии сохранения копирайта
    и добавления сведений о всех внесенных изменениях.

    ДАННОЕ ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ "КАК ЕСТЬ"
    БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ, ЯВНЫХ ИЛИ ПОДРАЗУМЕВАЕМЫХ. ВЫ
    ИСПОЛЬЗУЕТЕ ЕГО НА СВОЙ СОБСТВЕННЫЙ СТРАХ И РИСК. АВТОР
    НЕ БУДЕТ НЕСТИ ОТВЕТСТВЕННОСТЬ ЗА УТРАТУ ДАННЫХ, УЩЕРБ,
    УБЫТКИ ИЛИ ЛЮБЫЕ ДРУГИЕ ВИДЫ ПОТЕРЬ ПРИ ЛЮБЫХ СПОСОБАХ
    ИСПОЛЬЗОВАНИЯ ДАННОГО ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ.
-------------------------------------------------------------- */
#include <assert.h>
#include <malloc.h>
#include <memory.h>
#include <stdlib.h>
#include <string.h>
#define EXALLOC_OUT_OF_LINE
#include "Exarray.h"

#ifdef  _MSC_VER
#pragma auto_inline (off)
#endif/*_MSC_VER*/

/* --------------------------------------------------------------
    Проверяем поддержку выравнивания.
-------------------------------------------------------------- */

#ifndef _mm_malloc
#define _aligned_malloc(p,b,a)  malloc(b)
#define _aligned_realloc(p,b,a) realloc(p,b)
#define _aligned_free(p)        free(p)
#endif/*_mm_malloc*/

/* --------------------------------------------------------------
    Внешние ссылки объявлены, как "C", чтобы
    заблокировать преобразование имен.
    Это позволяет переносить объектные модули
    между различными версиями компиляторов.
-------------------------------------------------------------- */

#ifdef  __cplusplus
extern "C" {
#endif/*__cplusplus*/

/* --------------------------------------------------------------
    Заглушка динамического массива для присваивания
    динамическим указателям значения NULL.
-------------------------------------------------------------- */

struct  exblock_t VDECL exnull_c;

/* --------------------------------------------------------------
    Функция set_exalloc_handler() устанавливает
    обработчик ошибок распределения памяти,
    аналогичный set_new_handler().

    Параметры:
    pvf     Указатель на функцию типа void name (void) или
            NULL если для обработки ошибок следует вызвать
            (*exalloc_status.size_handler)();

    Выдает: Предыдущий указатель.
-------------------------------------------------------------- */

void (* set_exalloc_handler (void (*pvf) (void))) (void)
{
    static void (* pvfFailHandler)(void) = NULL;
    void (*pvfPrev) (void) = pvfFailHandler;
    pvfFailHandler = pvf;
    return pvfPrev;
}

/* --------------------------------------------------------------
    Функция exalloc_size_fail() вызывает обработчик ошибок
    распределения памяти до тех пор, пока он не равен NULL,
    затем вызывает abort().
-------------------------------------------------------------- */

void exalloc_size_fail (void)
{
    for (;;)
    {
        void (*pvf) (void) = set_exalloc_handler (NULL);
        set_exalloc_handler (pvf);
        if (pvf == NULL) break;
        (*pvf)();
    }
    abort();
}

/* --------------------------------------------------------------
    Функция exalloc_stub() не делает ничего.
-------------------------------------------------------------- */

void exalloc_stub (void) {}

/* --------------------------------------------------------------
    Функция exalloc_null_fail() вызывает abort.
-------------------------------------------------------------- */

static void exalloc_null_fail (void)
{
    #define NULL_POINTER_INDIRECTION 0
    assert (NULL_POINTER_INDIRECTION);
    abort();
}

/* --------------------------------------------------------------
    Функция exalloc_range_fail() вызывает abort.
-------------------------------------------------------------- */

static void exalloc_range_fail (void)
{
    #define INDEX_RANGE_ERROR 0
    assert (INDEX_RANGE_ERROR);
    abort();
}

/* --------------------------------------------------------------
    Обработчики частных ошибок и сведения
    o распределении памяти.

    Указатель функции, вызываемой при неустранимой
    ошибке распределения памяти. Функция должна возбудить
    исключение или прекратить работу программы.

    Указатель диагностической функции, вызываемой
    при автоматическом увеличении размера массива
    или NULL, если вызов диагностической функции
    не требуется. Может применяться для блокировки
    автоматического увеличения размера.

    Указатель функции, вызываемой при обращении
    по NULL-указателю. Функция должна возбудить
    исключение или прекратить работу программы.

    Указатель функции, вызываемой при выходе
    индекса за границы массива в том случае, если
    не предусмотрено автоматическое увеличение
    размера массива. Функция должна возбудить
    исключение или прекратить работу программы.
-------------------------------------------------------------- */

struct exalloc_status_t VDECL exalloc_status =
    { exalloc_size_fail, exalloc_stub,
      exalloc_null_fail, exalloc_range_fail,
      0, 0, 0, 0 };

/* --------------------------------------------------------------
    Функция exmalloc выделяет блок памяти, заполненный нулями.

    При переполнении разрядной сетки или нехватке памяти
    вызывается обработчик ошибок, установленный по
    exalloc_set_handler, иначе присвоенный
    exalloc_status.size_handler.

    Параметры:
    blocksize       Размер блока в байтах.

    Выдает:         Указатель на блок или NULL.
-------------------------------------------------------------- */

void*   FCDECL  exmalloc (size_t blocksize)
{
    void* p = NULL;
    exaligned_mrealloc (&p, blocksize, 1, 0, blocksize);
    return (p);
}

/* --------------------------------------------------------------
    Функция exaligned_malloc выделяет выровненный блок памяти,
    заполненный нулями.

    При переполнении разрядной сетки или нехватке памяти
    вызывается обработчик ошибок, установленный по
    exalloc_set_handler, иначе присвоенный
    exalloc_status.size_handler.

    Параметры:
    blocksize       Размер блока в байтах.
    blockalign      Выравнивание блока в байтах (2**n).

    Выдает:         Указатель на блок или NULL.
-------------------------------------------------------------- */

void*   FCDECL  exaligned_malloc (size_t blocksize, size_t blockalign)
{
    void* p = NULL;
    exaligned_mrealloc (&p, blocksize, blockalign, 0, blocksize);
    return (p);
}

/* --------------------------------------------------------------
    Функция exmrealloc() выделяет, удлиняет, укорачивает или
    освобождает блок памяти, а также обнуляет заданный участок.

    При переполнении разрядной сетки или нехватке памяти
    вызывается обработчик ошибок, установленный по
    exalloc_set_handler, иначе присвоенный
    exalloc_status.size_handler.

    Параметры:
    p               Адрес указателя блока.
                    *p == NULL при распределении.
                    *p != NULL при перераспределении.
                    Значение *p модифицируется.
    blocksize       Новый размер блока или 0
                    если блок должен быть освобожден.
    memset_start    Начало области обнуления.
    memset_stop     Конец области обнуления (не включая).
-------------------------------------------------------------- */

void    FCDECL  exmrealloc (void** p, size_t blocksize,
                 size_t memset_start, size_t memset_stop)
{
    exaligned_mrealloc (p, blocksize, 1, memset_start, memset_stop);
}

/* --------------------------------------------------------------
    Функция exaligned_mrealloc() выделяет, удлиняет, укорачивает
    или освобождает выровненный блок памяти, а также обнуляет
    заданный участок.

    При переполнении разрядной сетки или нехватке памяти
    вызывается обработчик ошибок, установленный по
    exalloc_set_handler, иначе присвоенный
    exalloc_status.size_handler.

    Параметры:
    p               Адрес указателя блока.
                    *p == NULL при распределении.
                    *p != NULL при перераспределении.
                    Значение *p модифицируется.
    blocksize       Новый размер блока или 0
                    если блок должен быть освобожден.
    blockalign      Выравнивание блока в байтах (2**n).
    memset_start    Начало области обнуления.
    memset_stop     Конец области обнуления (не включая).
-------------------------------------------------------------- */

void    FCDECL  exaligned_mrealloc (void** p,
                 size_t blocksize, size_t blockalign,
                 size_t memset_start, size_t memset_stop)
{
    void* pp = *p;                /* Значение p */

    /* Выделение памяти, если blocksize != 0 */

    if (blocksize)
    {
        /* (Пере)разместить блок и проверить результат */

        while (blocksize > EXCALCBLOCKSIZE_MAX - blockalign ||
              (pp = _aligned_realloc (*p, blocksize, blockalign))
              == NULL)
        {
            /* Вызвать обработчик ошибок распределения
               памяти и продолжить попытки размещения */

            void (*pvf) (void) = set_exalloc_handler (NULL);
            set_exalloc_handler (pvf);
            if (pvf != NULL) { (*pvf)(); continue; }

            /* Вызвать обработчик неустранимых ошибок
               распределения памяти и выйти */

            (*exalloc_status.size_handler)();
            exalloc_status.nBlocksFailed++;
            return;
        }

        /* Проверить выравнивание */

        if (((size_t)pp & (blockalign - 1)) != 0) {}

        /* Увеличить число размещенных блоков */

        if (pp != NULL)
        {
            exalloc_status.nBlocksAllocated++;
        }

        /* Инициализация */

        if (memset_stop > memset_start)
        {
             memset ((char*)pp + memset_start, 0,
                   memset_stop - memset_start);
        }

        /* Обновить информацию о выделении памяти */

        if (exalloc_status.pMinAlloc - 1 >= (char*) pp)
        {
            exalloc_status.pMinAlloc = (char*)pp;
        }
        if (exalloc_status.pMaxAlloc < (char*)pp + blocksize)
        {
            exalloc_status.pMaxAlloc = (char*)pp + blocksize;
        }
    }

    /* Освобождение памяти если blocksize == 0 и *p != NULL */

    else if (pp)
    {
        _aligned_free (pp); pp = NULL;
        exalloc_status.nBlocksAllocated--;
    }

    /* Обновить *p */

    *p = pp;
}

/* --------------------------------------------------------------
    Функция exfree() освобождает блок памяти.

    Параметры:
    p           Адрес блока или NULL.
-------------------------------------------------------------- */

void    FCDECL  exfree (void* p)
{
    exaligned_free (p);
}

/* --------------------------------------------------------------
    Функция exaligned_free() освобождает
    выровненный блок памяти.

    Параметры:
    p           Адрес блока или NULL.
-------------------------------------------------------------- */

void    FCDECL  exaligned_free (void* p)
{
    if (p)
    {
        _aligned_free (p);
        exalloc_status.nBlocksAllocated--;
    }
}

/* --------------------------------------------------------------
    Функция exrange() вызывает exalloc_status.null_handler
    или exalloc_status.range_handler в зависимости от p.

    Параметры:
    p           Адрес блока или NULL.
-------------------------------------------------------------- */

void    FCDECL  exrange (void* p)
{
    if (p == NULL)
            (*exalloc_status.null_handler)();
    else    (*exalloc_status.range_handler)();
}

/* --------------------------------------------------------------
    Функция excalcblocksize() рассчитывает
    оптимальный размер блока памяти в байтах,
    который должен быть не меньше требуемого.

    Начальный размер EXCALCBLOCKSIZE_MOD
    поочередно умножается на 2 и 1.5, пока
    станет больше запрошенного.
    Для уменьшения фрагментации динамической
    памяти при расчете учитывается размер
    системных данных EXCALCBLOCKSIZE_SYS,
    Значение EXCALCBLOCKSIZE_MOD задается
    как 64**n +/- 16, поэтому результирующая
    длина будет кратна 16 или 32, но не 64.

    Если запрошенный размер слишком велик,
    то выдается EXSIZE_T_MAX.

    Параметры:
    blocksize       Минимальный размер блока в байтах.

    Выдает:         Оптимальный размер в байтах или
                    EXSIZE_T_MAX.
-------------------------------------------------------------- */

size_t  FCDECL  excalcblocksize (size_t blocksize)
{
    size_t n = EXCALCBLOCKSIZE_MOD, k = 0;

    for (;; k = ~k, (k? (n <<= 1): (n += (n >> 1))))
    {
        n -= EXCALCBLOCKSIZE_SYS; if (n >= blocksize) break;
        n += EXCALCBLOCKSIZE_SYS; if ((ptrdiff_t) n < 0)
                               { n = EXSIZE_T_MAX; break; }
    }

    return (n);
}

/* --------------------------------------------------------------
    Функция exmuladd() вычисляет s*n+k
    в пределах 0..EXSIZE_T_MAX.
-------------------------------------------------------------- */

size_t  FCDECL  exmuladd (size_t s, size_t n, size_t k)
{
    return ((n <= (EXSIZE_T_MAX - k) / s)? (n * s + k): EXSIZE_T_MAX);
}

/* --------------------------------------------------------------
    Функция exmul() вычисляет s*n
    в пределах 0..EXSIZE_T_MAX.
-------------------------------------------------------------- */

size_t  FCDECL  exmul (size_t s, size_t n)
{
    return ((s == 1)? n: (n <= EXSIZE_T_MAX / s)? n * s: EXSIZE_T_MAX);
}

/* --------------------------------------------------------------
    Функция exadd() вычисляет n+k
    в пределах 0..EXSIZE_T_MAX.
-------------------------------------------------------------- */

size_t  FCDECL  exadd (size_t n, size_t k)
{
    return ((n <= EXSIZE_T_MAX - k)? (n + k): EXSIZE_T_MAX);
}

/* --------------------------------------------------------------
    Функция exchkadd() вычисляет n+k в пределах 0..max,
    иначе вызывается обработчик ошибок,
    присвоенный exalloc_status.size_handler.
-------------------------------------------------------------- */

size_t  FCDECL  exchkadd (size_t n, size_t k, size_t max)
{
    if (n > max - k) (*exalloc_status.size_handler)();
    return (n + k);
}

#ifdef  __cplusplus
}
#endif/*__cplusplus*/
